<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>gcc编译和Makefile</title>
      <link href="/2025/03/05/gcc-bian-yi-he-makefile/"/>
      <url>/2025/03/05/gcc-bian-yi-he-makefile/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-GCC的编译与链接"><a href="#1-GCC的编译与链接" class="headerlink" title="1. GCC的编译与链接"></a>1. GCC的编译与链接</h2><h3 id="1-1-GCC-编译-C-程序的过程"><a href="#1-1-GCC-编译-C-程序的过程" class="headerlink" title="1.1 GCC 编译 C 程序的过程"></a>1.1 GCC 编译 C 程序的过程</h3><h4 id="1-1-1-预处理（Preprocessing）"><a href="#1-1-1-预处理（Preprocessing）" class="headerlink" title="1.1.1 预处理（Preprocessing）"></a>1.1.1 预处理（Preprocessing）</h4><blockquote><p>预处理是编译过程的第一步，主要处理源代码中的预处理指令（以 <code>#</code> 开头），如 <code>#include</code>、<code>#define</code>、<code>#ifdef</code> 等。</p></blockquote><p><strong>示例代码（<code>test.c</code>）</strong>：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">define</span> PI 3.14</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The value of PI is %f\n"</span><span class="token punctuation">,</span> PI<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>预处理命令</strong>：</p><pre class="line-numbers language-sh"><code class="language-sh">gcc -E test.c -o test.i<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>-E</code> 选项告诉 GCC 只进行预处理。</li><li><code>-o</code> 选项指定输出文件的名称。</li></ul><p><strong>结果</strong>：<br>生成的 <code>test.i</code> 文件包含了展开头文件和宏定义后的代码。</p><h4 id="1-1-2-编译（Compilation）"><a href="#1-1-2-编译（Compilation）" class="headerlink" title="1.1.2 编译（Compilation）"></a>1.1.2 编译（Compilation）</h4><blockquote><p>编译阶段将预处理后的代码转换为汇编代码。</p></blockquote><p><strong>编译命令</strong>：</p><pre class="line-numbers language-sh"><code class="language-sh">gcc -S test.i -o test.s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>-S</code> 选项告诉 GCC 只进行编译，生成汇编代码。</li></ul><p><strong>结果</strong>：<br>生成的 <code>test.s</code> 文件包含了汇编语言代码。</p><h4 id="1-1-3-汇编（Assembly）"><a href="#1-1-3-汇编（Assembly）" class="headerlink" title="1.1.3 汇编（Assembly）"></a>1.1.3 汇编（Assembly）</h4><blockquote><p>汇编阶段将汇编代码转换为目标文件（二进制文件）。</p></blockquote><p><strong>汇编命令</strong>：</p><pre class="line-numbers language-sh"><code class="language-sh">gcc -c test.c -o test.o<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>-c</code> 选项告诉 GCC 只进行汇编，生成目标文件</li></ul><p><strong>结果</strong>：<br>生成的 <code>test.o</code> 文件是一个目标文件，包含了机器语言代码，但还不能直接运行。</p><h4 id="1-1-4-链接（Linking）"><a href="#1-1-4-链接（Linking）" class="headerlink" title="1.1.4 链接（Linking）"></a>1.1.4 链接（Linking）</h4><blockquote><p>链接阶段将目标文件和所需的库文件合并成一个可执行文件。</p></blockquote><p><strong>汇编和链接步骤</strong></p><pre class="line-numbers language-sh"><code class="language-sh"># 编译 main.c 和 func.c 生成目标文件gcc -c main.c -o main.ogcc -c func.c -o func.o# 链接两个目标文件生成可执行文件gcc main.o func.o -o main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>静态链接和动态链接</strong></p><p><strong>静态链接</strong></p><blockquote><p>静态链接是在链接阶段将所有依赖的库文件代码复制到可执行文件中。静态链接的可执行文件可以独立运行，但文件体积较大。</p></blockquote><p><strong>创建静态库：</strong></p><pre class="line-numbers language-sh"><code class="language-sh"># 编译生成目标文件gcc -c func.c -o func.o# 创建静态库ar rcs libfunc.a func.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>ar</code> 是一个归档工具，<code>r</code> 表示将文件插入到归档文件中，<code>c</code> 表示创建归档文件，<code>s</code> 表示写入符号表。</li></ul><p><strong>使用静态库进行链接</strong>：</p><pre class="line-numbers language-sh"><code class="language-sh">gcc main.c -L. -lfunc -o main<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>-L.</code> 表示在当前目录下查找库文件。</li><li><code>-lfunc</code> 表示链接名为 <code>libfunc.a</code> 的静态库。</li></ul><p><strong>动态链接</strong></p><blockquote><p>动态链接是在程序运行时才加载所需的库文件。动态链接的可执行文件体积较小，但依赖于系统中安装的动态库。</p></blockquote><p><strong>创建动态库</strong>：</p><pre class="line-numbers language-sh"><code class="language-sh"># 编译生成目标文件gcc -fPIC -c func.c -o func.o# 创建动态库gcc -shared -o libfunc.so func.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>-fPIC</code> 选项表示生成位置无关代码。</li><li><code>-shared</code> 选项表示创建动态库。</li></ul><p><strong>使用动态库进行链接</strong>：</p><pre class="line-numbers language-sh"><code class="language-sh">gcc main.c -L. -lfunc -o main<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>与静态链接的命令相同，但链接的是动态库 <code>libfunc.so</code>。</li></ul><p><strong>运行使用动态库的程序</strong>：<br>在运行程序之前，需要告诉系统动态库的搜索路径。可以通过设置 <code>LD_LIBRARY_PATH</code> 环境变量来实现：</p><pre class="line-numbers language-sh"><code class="language-sh">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:../main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2-Makefile简述"><a href="#2-Makefile简述" class="headerlink" title="2.Makefile简述"></a>2.Makefile简述</h2><h3 id="2-1-为什么需要Makefile"><a href="#2-1-为什么需要Makefile" class="headerlink" title="2.1 为什么需要Makefile"></a>2.1 为什么需要Makefile</h3><p>现在一些项目工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，如果仍然在终端输入这些命令来编译，那显然不切实际，开发效率极低。 我们需要一个工具来管理这些编译过程，这就是“make”。make 是一个应用程序，它根据 Makefile 来做事。Makefile 负责管理整个编译流程：要编译哪些文件？怎么编译这些文件？怎么把它们链接成一个可执行程序。Makefile 定义了一系列的规则来实现这些管理。</p><h3 id="2-2-makefie的引入"><a href="#2-2-makefie的引入" class="headerlink" title="2.2 makefie的引入"></a>2.2 makefie的引入</h3><p>Makefile 的引入是为了简化我们编译流程，提高我们的开发进度。下面我们用一个例子来说明 Makefile 如何简化我们的编译流程。我们创建一个工程内容分别 <code>main.c，sub.c，sub.h，add.c，add.h</code> 五个文件。<code>sub.c</code> 负责计算两个数减法运算，<code>add.c</code> 负责计算两个数加法运算，然后编译出可执行文件。其源文件内容如下：</p><pre class="line-numbers language-c"><code class="language-c">main<span class="token punctuation">.</span>c：<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"add.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"sub.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"100 ask, add:%d\n"</span><span class="token punctuation">,</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"100 ask, sub:%d\n"</span><span class="token punctuation">,</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span>add<span class="token punctuation">.</span>c：<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"add.h"</span></span><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span>add<span class="token punctuation">.</span>h：<span class="token macro property">#<span class="token directive keyword">ifndef</span> __ADD_H</span><span class="token macro property">#<span class="token directive keyword">define</span> __ADD_H</span><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>sub<span class="token punctuation">.</span>c：<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"sub.h"</span></span><span class="token keyword">int</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span>sub<span class="token punctuation">.</span>h：<span class="token macro property">#<span class="token directive keyword">ifndef</span> __SUB_H</span><span class="token macro property">#<span class="token directive keyword">define</span> __SUB_H</span><span class="token keyword">int</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们使用 <code>gcc </code>对上面工程进行编译及生成可执行程序，在终端输入如下命令，如下：</p><pre class="line-numbers language-bash"><code class="language-bash">$ gcc main.c sub.c add.c -o ouput$ <span class="token function">ls</span>add.c add.h main.c output sub.c sub.h$ ./output100 ask, add:20100 ask, sub:10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的命令是通过 <code>gcc</code> 编译器对 <code>main.c sub.c add.c</code> 这三个文件进行编译，及生成可执行程序 output，并执行可执行文件产生结果。 从上面的例子看起来比较简单，一条命令完成三个源程序的编译并产生结果，这是因为目前只有三个源文件。</p><p>如果有上千个源文件，即使你只修改了其中一个文件，你执行这样的命令时，它会把所有的源文件都编译一次。这样消耗的时间是非常恐怖的。 我们想实现：哪个文件被修改了，只编译这个被修改的文件即可，其它没有修改的文件就不需要再次重新编译了。可以使用下列命令，先单独编译文件，再最后链接，如下：</p><pre class="line-numbers language-bash"><code class="language-bash">$ gcc -c main.c$ gcc -c sub.c$ gcc -c add.c$ gcc main.o sub.o add.o -o output<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们将上面一条命令变成了四条，分别编译出源文件的目标文件，最后再将所有的目标文件链接成可执行文件。 当其中一个源文件的内容发生了变化，我们只需要单独编译它，然后跟其他文件重新链接成可知执行文件，不再需要重新编译其他文件。 假如我们修改了 <code>add.c</code> 文件，只需要重新编译生成 <code>add.c</code> 的目标文件，然后再将所有的.o 文件链接成可执行文件，如下：</p><pre class="line-numbers language-bash"><code class="language-bash">$ gcc -c add.c$ gcc main.o sub.o add.o -o output<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样的方式虽然可以节省时间，但是仍然存在几个问题，如下：</p><ul><li>如果源文件的数目很多，那么我们需要花费大量的时间，敲命令执行。</li><li>如果源文件的数目很多，然后修改了很多文件，后面发现忘记修改了什么。</li><li>如果头文件的内容修改，替换，更换目录，所有依赖于这个头文件的源文件全部需要重新编译。 这些问题我们不可能一个一个去找和排查，引入 Makefile 可以解决上述问题。我们先扔出一个 Makefile，如下：</li></ul><pre class="line-numbers language-makefile"><code class="language-makefile">Makefile：<span class="token symbol">output</span><span class="token punctuation">:</span> main.o add.o sub.o    gcc -o output main.o add.o sub.o<span class="token symbol">main.o</span><span class="token punctuation">:</span> main.c    gcc -c main.c<span class="token symbol">add.o</span><span class="token punctuation">:</span> add.c    gcc -c add.c<span class="token symbol">sub.o</span><span class="token punctuation">:</span> sub.c    gcc -c sub.c<span class="token symbol">clean</span><span class="token punctuation">:</span>    rm *.o output<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Makefile 编写好后只需要执行 <code>make</code> 命令，就可以自动帮助我们编译工程。注意，<code>make</code> 命令必须要在 Makefile 的当前目录执行，如下：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ls</span>add.c add.h main.c Makefile sub.c sub.h$ <span class="token function">make</span>gcc -c main.cgcc -c add.cgcc -c sub.cgcc -o output main.o add.o sub.o$ <span class="token function">ls</span>add.c add.h add.o main.c main.o Makefile output sub.c sub.h sub.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过 <code>make</code> 命令就可以生成相对应的目标文件.o 和可执行文件。 如果我们再次使用 <code>make</code> 命令编译，如下，它说你的程序已经是最新的了，不需要再做什么事情：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">make</span>make: <span class="token string">'output'</span> is up to date.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们可以修改一下 <code>add.c</code>，然后再执行 <code>make</code>，如下：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">make</span>gcc -c add.cgcc -o output main.o add.o sub.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>会发现，它重新编译了 <code>add.c</code>，并且重新生成了可执行程序。 通过上述例子，Makefile 将我们上面的三个问题都解决了，无需手工输入复杂的命令，只编译修改过的文件。在一个很庞大的工程中，只有第一次编译时间比较长，第二次编译时会大大缩短时间，节省了我们的开发周期。 下面我们来学习 Makefile 的知识。</p><h2 id="3-变量"><a href="#3-变量" class="headerlink" title="3.变量"></a>3.变量</h2><h3 id="3-1-变量的定义及取值"><a href="#3-1-变量的定义及取值" class="headerlink" title="3.1 变量的定义及取值"></a>3.1 变量的定义及取值</h3><p>Makefile 也支持变量定义，变量的定义也让的我们的 Makefile 更加简化，可复用。 变量的定义：一般采用大写字母，赋值方式像 C 语言的赋值方式一样，如下：</p><pre class="line-numbers language-bash"><code class="language-bash">DIR <span class="token operator">=</span> ./100ask/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>变量取值：使用括号将变量括起来再加美元符，如下：</p><pre class="line-numbers language-bash"><code class="language-bash">FOO <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>DIR<span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>变量可让 Makefile 简化可复用，上面个的 Makefile 文件，内容如下：</p><pre class="line-numbers language-makefile"><code class="language-makefile"><span class="token symbol">output</span><span class="token punctuation">:</span> main.o add.o sub.o    gcc -o output main.o add.o sub.o<span class="token symbol">main.o</span><span class="token punctuation">:</span> main.c    gcc -c main.c<span class="token symbol">add.o</span><span class="token punctuation">:</span> add.c    gcc -c add.c<span class="token symbol">sub.o</span><span class="token punctuation">:</span> sub.c    gcc -c sub.c<span class="token symbol">clean</span><span class="token punctuation">:</span>    rm *.o output<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以将其优化，如下：</p><pre class="line-numbers language-makefile"><code class="language-makefile"><span class="token comment" spellcheck="true">#Makefile 变量定义</span>OBJ <span class="token operator">=</span> main.o add.o sub.o<span class="token symbol">output</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>OBJ<span class="token punctuation">)</span>    gcc -o output <span class="token variable">$</span><span class="token punctuation">(</span>OBJ<span class="token punctuation">)</span><span class="token symbol">main.o</span><span class="token punctuation">:</span> main.c    gcc -c main.c<span class="token symbol">add.o</span><span class="token punctuation">:</span> add.c    gcc -c add.c<span class="token symbol">sub.o</span><span class="token punctuation">:</span> sub.c    gcc -c sub.c<span class="token symbol">clean</span><span class="token punctuation">:</span>    rm <span class="token variable">$</span><span class="token punctuation">(</span>OBJ<span class="token punctuation">)</span> output<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们分析一下上面简化过的 Makefile，第一行是注释，Makefile 的注释采用‘#’，而且不支持像 C 语言中的多行注释。第二行我们定义了变量 OBJ，并赋值字符串<code>"main.o，add.o，sub.o"</code>。其中第三，四，十三行，使用这个变量。这样用到用一个字符串的地方直接调用这个变量，无需重复写一大段字符串。 Makefile 除了使用<code>=</code>进行赋值，还有其他赋值方式，比如<code>:=</code>和<code>?=</code>，接下来我们来对比一下这几种的区别：</p><p>赋值符<code>=</code> 我们使用一个例子来说明赋值符<code>=</code>的用法。Makefile 内容如下：</p><pre class="line-numbers language-makefile"><code class="language-makefile">PARA <span class="token operator">=</span> 100CURPARA <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>PARA<span class="token punctuation">)</span>PARA <span class="token operator">=</span> ask<span class="token symbol">print</span><span class="token punctuation">:</span>    <span class="token operator">@</span>echo <span class="token variable">$</span><span class="token punctuation">(</span>CURPARA<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分析代码：第一行定义变量 <code>PARA</code>，并赋值为“100”，第二行定义变量<code> CURPARA</code>，并赋值引用变量 <code>PARA</code>，此时<code>CURPARA</code> 的值和 PARA 的值是一样的，第三行，将变量 <code>PARA</code> 的变量修改为<code>ask</code>。第六行输出 <code>CURPARA </code>的值，echo 前面增加<code>@符号，代表只显示命令的结果，不显示命令本身</code>。 通过命令<code>make print</code>执行 Makefile，如下：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">make</span> printask<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>从结果上看，变量 <code>CURPARA</code> 的值并不是“100”，而是 PARA 的最后一次赋值。使用赋值符<code>=</code>设置的变量，它的值在运行时才能确定，这称为“延时变量”。 其实可以理解为在 C 语言中，定义一个指针变量指向一个变量的地址。如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>a<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>代码分析：我们见上面的 Makefile 的第二行的<code>=</code>替换成<code>:=</code>，重新编译，如下：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">make</span> print100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>从结果上看，变量 <code>CURPARA</code> 的值为“100”。使用<code>:=</code>设置的变量被称为“即时变量”，在赋值时就确定了它的值。</p><p>赋值符<code>?=</code></p><p>我们用两个 Makefile 来说明赋值符<code>?=</code>的用法。如下：</p><pre class="line-numbers language-makefile"><code class="language-makefile">第一个 Makefile：PARA <span class="token operator">=</span> 100PARA <span class="token operator">?=</span> ask<span class="token symbol">print</span><span class="token punctuation">:</span>    <span class="token operator">@</span>echo <span class="token variable">$</span><span class="token punctuation">(</span>PARA<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译结果：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">make</span> print100第二个 Makefile:PARA ?<span class="token operator">=</span> askprint:    @echo <span class="token variable"><span class="token variable">$(</span>PARA<span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译结果：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">make</span> printask<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上面的例子说明，使用<code>?=</code>给变量设置值时，如果这个变量之前没有被设置过，那么“?=”才会起效果；如果曾经设置过这个变量，那么<code>?=</code>不会起效果。赋值符<code>+=</code> Makefile 中的变量是字符串，有时候我们需要给前面已经定义好的变量添加一些字符串进去,此时就要使用到符号<code>+=</code>，比如如下：</p><pre class="line-numbers language-makefile"><code class="language-makefile">OBJ <span class="token operator">=</span> main.o add.oOBJ <span class="token operator">+=</span> sub.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样的结果是 OBJ 的值为：<code>main.o，add.o，sub.o</code>。说明<code>+=</code>用作与变量的追加。</p><h3 id="3-2-系统自带变量"><a href="#3-2-系统自带变量" class="headerlink" title="3.2 系统自带变量"></a>3.2 系统自带变量</h3><p>系统自定义了一些变量，通常都是大写，比如 CC，PWD，CLFAG 等等，有些有默认值，有些没有，比如以下几种，如下：</p><ul><li><code>CPPFLAGS</code>：预处理器需要的选项，如：-l</li><li><code>CFLAGS</code>：编译的时候使用的参数，-Wall -g -c</li><li><code>LDFLAGS</code>：链接库使用的选项，-L -l 其中：默认值可以被修改，比如 CC 默认值是 cc，但可以修改为 gcc：CC=gcc使用的例子，如下：</li></ul><pre class="line-numbers language-text"><code class="language-text">OBJ = main.o add.o sub.ooutput: $(OBJ)    gcc -o output $(OBJ)main.o: main.c    gcc -c main.cadd.o: add.c    gcc -c add.csub.o: sub.c    gcc -c sub.cclean:    rm $(OBJ) output<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用系统自带变量，如下：</p><pre class="line-numbers language-text"><code class="language-text">CC = gccOBJ = main.o add.o sub.ooutput: $(OBJ)    $(CC) -o output $(OBJ)main.o: main.c    $(CC) -c main.cadd.o: add.c    $(CC) -c add.csub.o: sub.c    $(CC) -c sub.cclean:    rm $(OBJ) output<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面例子中，系统变量 CC 不改变默认值，也同样可以编译，修改的目的是为了明确使用 gcc 编译。</p><h3 id="3-3-自动变量"><a href="#3-3-自动变量" class="headerlink" title="3.3 自动变量"></a>3.3 自动变量</h3><p>Makefile 的语法提供一些自动变量，这些变量可以让我们更加快速地完成Makefile 的编写，其中自动变量只能在规则中的命令使用，常用的自动变量如 下：</p><ul><li><code>$@</code>：规则中的目标</li><li><code>$&lt;</code>：规则中的第一个依赖文件</li><li><code>$^</code>：规则中的所有依赖文件 我们上面的例子继续完善，修改为采用自动变量的格式，如下:</li></ul><pre class="line-numbers language-makefile"><code class="language-makefile">CC <span class="token operator">=</span> gccOBJ <span class="token operator">=</span> main.o add.o sub.o<span class="token symbol">output</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>OBJ<span class="token punctuation">)</span>    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -o <span class="token variable">$@</span> <span class="token variable">$^</span><span class="token symbol">main.o</span><span class="token punctuation">:</span> main.c    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -c <span class="token variable">$&lt;</span><span class="token symbol">add.o</span><span class="token punctuation">:</span> add.c    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -c <span class="token variable">$&lt;</span><span class="token symbol">sub.o</span><span class="token punctuation">:</span> sub.c    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -c <span class="token variable">$&lt;</span><span class="token symbol">clean</span><span class="token punctuation">:</span>    rm <span class="token variable">$</span><span class="token punctuation">(</span>OBJ<span class="token punctuation">)</span> output<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中：第 4 行<code>$^</code>表示变量 OBJ 的值，即 <code>main.o add.o sub.o</code>，第四，第六，第八行的<code>$&lt;</code>分别表示 <code>main.c add.c sub.c</code>。<code>$@</code>表示<code> output</code>。</p><h2 id="4-模式规则与伪目标"><a href="#4-模式规则与伪目标" class="headerlink" title="4.模式规则与伪目标"></a>4.模式规则与伪目标</h2><h3 id="4-1模式规则"><a href="#4-1模式规则" class="headerlink" title="4.1模式规则"></a>4.1模式规则</h3><p>模式规则实在目标及依赖中使用%来匹配对应的文件，我们依旧使用上面的例子，采用模式规则格式，如下：</p><pre class="line-numbers language-makeflie"><code class="language-makeflie">CC = gccOBJ = main.o add.o sub.ooutput: $(OBJ)    $(CC) -o $@ $^%.o: %.c    $(CC) -c $<clean:    rm $(OBJ) output<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中：第五行<code>%.o: %.c</code>表示如下:</p><ol><li><p>main.o 由 main.c 生成 </p></li><li><p>add.o 由 add.c 生成 </p></li><li><p>sub.o 由 sub.c 生成</p></li></ol><h3 id="4-2伪目标"><a href="#4-2伪目标" class="headerlink" title="4.2伪目标"></a>4.2伪目标</h3><p>在前面的例子中，我们直接执行<code>make</code>命令，它的目的是去执行第 1 个规则，这跟执行<code>make output</code>的效果是一样的。在这里，<code>output</code>既是规则的目标，也是一个实际的文件。 而伪目标是什么呢？对于以前的例子，先执行 make 命令，然后再执行<code>make clean</code>命令，如下</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token variable">$make</span>gcc -c main.cgcc -c add.cgcc -c sub.cgcc -o output main.o add.o sub.o<span class="token variable">$make</span> clean<span class="token function">rm</span> *.o output<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一切正常！接着我们做个手脚，在 Makefile 目录下创建一个 clean 的文件，然后依旧执行 make 和 make clean，如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token variable">$touch</span> clean<span class="token variable">$make</span>gcc -c main.cgcc -c add.cgcc -c sub.cgcc -o output main.o add.o sub.o<span class="token variable">$make</span> cleanmake: <span class="token string">'clean'</span> is up to date.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为什么<code>make clean</code>时命令没有被执行？因为已经有名为 clean 的文件了，并且它的依赖是空的，执行规则的条件没满足。 </p><p>伪目标就是为了解决这个问题，我们在 clean 前面增加<code>.PHONY:clean</code>，如下：</p><pre class="line-numbers language-makefile"><code class="language-makefile">CC <span class="token operator">=</span> gccOBJ <span class="token operator">=</span> main.o add.o sub.o<span class="token symbol">output</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>OBJ<span class="token punctuation">)</span>    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -o <span class="token variable">$@</span> <span class="token variable">$^</span><span class="token symbol">%.o</span><span class="token punctuation">:</span> %.c    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -c <span class="token variable">$&lt;</span><span class="token builtin">.PHONY</span><span class="token punctuation">:</span>clean<span class="token symbol">clean</span><span class="token punctuation">:</span>    rm <span class="token variable">$</span><span class="token punctuation">(</span>OBJ<span class="token punctuation">)</span> output<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token variable">$make</span>gcc -c main.cgcc -c add.cgcc -c sub.cgcc -o output main.o add.o sub.o<span class="token variable">$make</span> clean<span class="token function">rm</span> *.o output<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当一个目标被声明为伪目标后，make 在执行规则时就会默认它满足执行条件。 这样就提高了 make 的执行效率，也不用担心由于目标和文件名重名了。 </p><p>伪目标的两大好处： </p><ol><li>避免只执行命令的目标和工作目录下的实际文件出现名字冲突。 </li><li>提高执行 Makefile 时的效率</li></ol><h2 id="5-Makefile函数"><a href="#5-Makefile函数" class="headerlink" title="5.Makefile函数"></a>5.Makefile函数</h2><p>Makefile 提供了大量的函数，函数调用的格式如下：</p><pre class="line-numbers language-text"><code class="language-text">$(function arguments)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里<code>function是函数名</code>，<code>arguments</code>是该函数的参数。参数和函数名之间是用空格或 Tab 隔开，如果有多个参数，它们之间用逗号隔开。这些空格和逗号不是参数值的一部分。 我们经常使用的函数主要有两个(wildcard，patsubst)，先把它们单独拎出来讲讲。创建一个文件夹 src，在里下面创建两个文件，100.c，ask.c。如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token keyword">.</span>├── Makefile└── src    ├── 100.c    └── ask.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-1常用函数"><a href="#5-1常用函数" class="headerlink" title="5.1常用函数"></a>5.1常用函数</h3><blockquote><p><strong>wildcard 函数</strong></p></blockquote><p>用于查找指定目录下指定类型的文件，函数参数：目录+文件类型，如下：</p><pre class="line-numbers language-makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">wildcard</span> 指定文件类型<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，指定文件类型，如果不写路径，则默认为当前目录查找，例子如下：</p><pre class="line-numbers language-makefile"><code class="language-makefile">01 SRC <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">wildcard</span> ./src/*.c<span class="token punctuation">)</span>02<span class="token symbol">03 print</span><span class="token punctuation">:</span>04 <span class="token operator">@</span>echo <span class="token variable">$</span><span class="token punctuation">(</span>SRC<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>执行命令 make，结果如下：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">make</span>./src/ask.c ./src/100.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其中，这条规则表示：找到目录./src 下所有后缀为.c 的文件，并赋值给变量SRC。命令执行完，SRC 变量的值：./src/ask.c ./src/100.c</p><blockquote><p><strong>patsubst 函数</strong></p></blockquote><p>用于匹配替换。函数参数：原模式+目标模式+文件列表，如下:</p><pre class="line-numbers language-makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span> patsubst 原模式, 目标模式, 文件列表<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，从文件列表中查找出符合原模式文件类型的文件，然后一一替换成目标模式。举例：将./src 目录下的.c 结尾的文件，替换成.o 文件，并赋值给 obj。 如下：</p><pre class="line-numbers language-makefile"><code class="language-makefile">SRC <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">wildcard</span> ./src/*.c<span class="token punctuation">)</span>OBJ <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">patsubst</span> %.c, %.o, <span class="token variable">$</span><span class="token punctuation">(</span>SRC<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token symbol">print</span><span class="token punctuation">:</span>    <span class="token operator">@</span>echo <span class="token variable">$</span><span class="token punctuation">(</span>OBJ<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>执行命令 make，结果如下：</p><pre class="line-numbers language-text"><code class="language-text">$ make./src/ask.o ./src/100.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其中，这条规则表示：把变量中所有后缀为.c 的文件替换为.o。 命令执行完，OBJ 变量的值：./src/ask.o ./src/100.o</p><h3 id="5-2-字符串替换和分析函数"><a href="#5-2-字符串替换和分析函数" class="headerlink" title="5.2 字符串替换和分析函数"></a>5.2 字符串替换和分析函数</h3><blockquote><p><strong>$(subst from,to,text)</strong></p></blockquote><p>在文本<code>text中使用to替换每一处from</code>。比如：</p><pre class="line-numbers language-makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">subst</span> ee,EE,feet on the street<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果为<code>fEEt on the strEEt</code>。</p><blockquote><p><strong>$(patsubst pattern,replacement,text)</strong></p></blockquote><p>寻找<code>text中符合格式pattern</code>的字，用<code>replacement替换它们</code>。 <code>pattern</code>和<code>replacement</code>中可以使用通配符。比如：</p><pre class="line-numbers language-makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">patsubst</span> %.c,%.o,x.c.c bar.c）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果为：<code>x.c.o bar.o</code>。</p><p><strong>$(strip string)</strong> 去掉前导和结尾空格，并将中间的多个空格压缩为单个空格。比如：</p><pre class="line-numbers language-makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">strip</span> a b c <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果为<code>a b c</code>。</p><blockquote><p><strong>$(findstring find,in)</strong></p></blockquote><p>在字符串<code>in中搜寻find</code>，如果找到，则返回值是<code>find</code>，否则返回值为空。比如：</p><pre class="line-numbers language-makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">findstring</span> a,a b c<span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">findstring</span> a,b c<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>将分别产生值<code>a</code>和<code>""</code>(空字符串)。</p><blockquote><p><strong>$(filter pattern…,text)</strong></p></blockquote><p>返回在<code>text中由空格隔开且匹配格式pattern...</code>的字，去除不符合格式<code>pattern...</code>的字。比如</p><pre class="line-numbers language-makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">filter</span> %.c %.s,foo.c bar.c baz.s ugh.h<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果为<code>foo.c bar.c baz.s</code>。</p><blockquote><p><strong>$(filter-out pattern…,text)</strong></p></blockquote><p>返回在<code>text中由空格隔开且不匹配格式pattern...</code>的字，去除符合格式<code>pattern...</code>的字。它是函数 filter 的反函数。比如：</p><pre class="line-numbers language-makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">filter</span> %.c %.s,foo.c bar.c baz.s ugh.h<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果为<code>ugh.h</code>。</p><blockquote><p><strong>$(sort list)</strong></p></blockquote><p>将<code>list中的字按字母顺序排序，并去掉重复的字</code>。输出由单个空格隔开的字的列表。比如：</p><pre class="line-numbers language-makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">sort</span> foo bar lose<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回值是<code>bar foo lose</code>。</p><h3 id="5-3-文件名函数"><a href="#5-3-文件名函数" class="headerlink" title="5.3 文件名函数"></a>5.3 文件名函数</h3><blockquote><p><strong>$(dir names…)</strong></p></blockquote><p>抽取<code>names...中每一个文件名的路径部分</code>，文件名的路径部分包括从文件名的首字符到最后一个斜杠(含斜杠)之前的一切字符。比如：</p><pre class="line-numbers language-makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">dir</span> src/foo.c hacks<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果为<code>src/ ./</code>。</p><blockquote><p><strong>$(notdir names…)</strong></p></blockquote><p>抽取<code>names...中每一个文件名中除路径部分外一切字符（真正的文件名）</code>。比如：</p><pre class="line-numbers language-makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">notdir</span> src/foo.c hacks<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果为<code>foo.c hacks</code>。</p><blockquote><p><strong>$(suffix names…)</strong></p></blockquote><p>抽取<code>names...中每一个文件名的后缀</code>。比如：</p><pre class="line-numbers language-makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">suffix</span> src/foo.c src-1.0/bar.c hacks<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果为<code>.c .c</code>。</p><blockquote><p><strong>$(basename names…)</strong></p></blockquote><p>抽取<code>names...中每一个文件名中除后缀外一切字符</code>。比如：</p><pre class="line-numbers language-makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">basename</span> src/foo.c src-1.0/bar hacks<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果为<code>src/foo src-1.0/bar hacks</code>。</p><blockquote><p><strong>$(addsuffix suffix,names…)</strong></p></blockquote><p>参数<code>names...</code>是一系列的文件名，文件名之间用空格隔开；<code>suffix </code>是一个后缀名。将 suffix(后缀)的值附加在每一个独立文件名的后面，完成后将文件名串联起来，它们之间用单个空格隔开。比如：</p><pre class="line-numbers language-makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">addsuffix</span> .c,foo bar<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果为<code>foo.c bar.c</code>。</p><blockquote><p><strong>$(addprefix prefix,names…)</strong></p></blockquote><p>参数<code>names</code>是一系列的文件名，文件名之间用空格隔开；<code>prefix</code> 是一个前缀名。将 preffix(前缀)的值附加在每一个独立文件名的前面，完成后将文件名串联起来，它们之间用单个空格隔开。比如：</p><pre class="line-numbers language-makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span>addprefix src/,foo bar<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果为<code>src/foo src/bar</code>。</p><blockquote><p><strong>$(wildcard pattern)</strong></p></blockquote><p>参数<code>pattern</code>是一个文件名格式，包含有通配符(通配符和 shell 中的用法一样)。函数 wildcard 的结果是一列和格式匹配的且真实存在的文件的名称，文件名之间用一个空格隔开。 比如若当前目录下有文件<code> 1.c、2.c、1.h、2.h</code>，则:</p><pre class="line-numbers language-makefile"><code class="language-makefile">c_src <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">wildcard</span> *.c<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果为<code>1.c 2.c</code>。</p><h3 id="5-4-其他函数"><a href="#5-4-其他函数" class="headerlink" title="5.4 其他函数"></a>5.4 其他函数</h3><blockquote><p><strong>$(foreach var,list,text)</strong></p></blockquote><p>前两个参数，<code>var</code>和‘<code>list</code>将首先扩展，注意最后一个参数<code>text</code>，此时不扩展；接着，<code>list</code>扩展所得的每个字，都赋给<code>var</code>变量；然后<code>text</code>引用该变量进行扩展，因此<code>text</code>每次扩展都不相同。 函数的结果是由空格隔开的<code>text</code> 在<code>list</code>中多次扩展后，得到的新<code>list</code>，就是说：<code>text</code>多次扩展的字串联起来，字与字之间由空格隔开，如此就产生了函数 <code>foreach</code>的返回值。 下面是一个简单的例子，将变量<code>files</code>的值设置为<code>dirs</code>中的所有目录下的所有文件的列表：</p><pre class="line-numbers language-makefile"><code class="language-makefile">dirs <span class="token operator">:=</span> a b c dfiles <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">foreach</span> dir,<span class="token variable">$</span><span class="token punctuation">(</span>dirs<span class="token punctuation">)</span>,<span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">wildcard</span> <span class="token variable">$</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span>/*<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里<code>text是‘$(wildcard $(dir)/*)</code>，它的扩展过程如下：</p><p>a) 第一个赋给变量 dir 的值是<code>a</code>，扩展结果为<code>$(wildcard a/*)</code>； </p><p>b) 第二个赋给变量 dir 的值是<code>b</code>，扩展结果为<code>$(wildcard b/*)</code>；</p><p>c) 第三个赋给变量 dir 的值是<code>c</code>，扩展结果为<code>$(wildcard c/*)</code>； </p><p>d) 如此继续扩展。</p><p>这个例子和下面的例有共同的结果：</p><pre class="line-numbers language-makefile"><code class="language-makefile">files <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">wildcard</span> a/* b/* c/* d/*<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><strong>$(if condition,then-part[,else-part])</strong></p></blockquote><p>首先把第一个参数<code>condition</code>的前导空格、结尾空格去掉，然后扩展。如果扩展为非空字符串，则条件<code>condition</code>为<code>真</code>；如果扩展为空字符串，则条件<code>condition</code>为<code>假</code>。 如果条件<code>condition</code>为<code>真</code>,那么计算第二个参数<code>then-part</code>的值，并将该值作为整个函数 if 的值。 如果条件<code>condition</code>为<code>假</code>,并且第三个参数存在，则计算第三个参数<code>else-part</code>的值，并将该值作为整个函数 if 的值；如果第三个参数不存在，函数 if 将什么也不计算，返回空值。 注意：仅能计算<code>then-part</code>和<code>else-part</code>二者之一，不能同时计算。这样有可能产生副作用（例如函数 shell 的调用）。</p><blockquote><p><strong>$(origin variable)</strong></p></blockquote><p>变量<code>variable</code>是一个查询变量的名称，不是对该变量的引用。所以，不能采用<code>$</code>和圆括号的格式书写该变量，当然，如果需要使用非常量的文件名，可以在文件名中使用变量引用。</p><p>函数 origin 的结果是一个字符串，该字符串变量是这样定义的：</p><ul><li><code>undefined</code>：如果变量<code>variable</code>从没有定义；</li><li><code>default</code>：变量<code>variable</code>是缺省定义；</li><li><code>environment</code>：变量<code>variable</code>作为环境变量定义，选项<code>-e</code>没有打开；</li><li><code>environment override</code>：变量<code>variable</code>作为环境变量定义，选项<code>-e</code>已打开；</li><li><code>file</code> ：变量<code>variable</code>在 Makefile 中定义；</li><li><code>command line</code>：变量<code>variable</code>在命令行中定义；</li><li><code>override</code>：变量<code>variable</code>在 Makefile 中用 override 指令定义；</li><li><code>automatic</code>：变量<code>variable</code>是自动变量</li></ul><blockquote><p><strong>$(shell command arguments)</strong></p></blockquote><p>函数 shell 是 make 与外部环境的通讯工具。函数 shell 的执行结果和在控制台上执行<code>command arguments</code>的 结果相似。 不过如果 <code>command arguments</code>的结果含有换行符（和回车符），则在函数 shell 的返回结果中将把它们处理为单个空格，若返回结果最后是换行符（和回车符）则被去掉。 比如当前目录下有文件 <code>1.c、2.c、1.h、2.h</code>，则：</p><pre class="line-numbers language-makefile"><code class="language-makefile">c_src <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">shell</span> ls *.c<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果为<code>1.c 2.c</code>。</p><h2 id="6-Makefile实例"><a href="#6-Makefile实例" class="headerlink" title="6.Makefile实例"></a>6.Makefile实例</h2><p>在上面的例子中，我们都是把头文件，源文件放在同一个文件里面，这样不好用于维护，所以我们将其分类，把它变得更加规范一下，把所有的头文件放在文件夹：inc，把所有的源文件放在文件夹：src。 代码目录如下：</p><pre class="line-numbers language-bash"><code class="language-bash">$ tree<span class="token keyword">.</span>├── inc│ ├── add.h│ └── sub.h├── Makefile└── src    ├── add.c    ├── main.c    └── sub.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中 Makefile 的内容如下：</p><pre class="line-numbers language-makefile"><code class="language-makefile">SOURCE <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">wildcard</span> ./src/*.c<span class="token punctuation">)</span>OBJECT <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">patsubst</span> %.c, %.o, <span class="token variable">$</span><span class="token punctuation">(</span>SOURCE<span class="token punctuation">)</span><span class="token punctuation">)</span>INCLUEDS <span class="token operator">=</span> -I ./incTARGET <span class="token operator">=</span> 100askCC <span class="token operator">=</span> gccCFLAGS <span class="token operator">=</span> -Wall -g<span class="token symbol"><span class="token variable">$</span>(TARGET)</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>OBJECT<span class="token punctuation">)</span>    <span class="token operator">@</span>mkdir -p output/    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$^</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGES<span class="token punctuation">)</span> -o output/<span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span><span class="token symbol">%.o</span><span class="token punctuation">:</span> %.c    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>INCLUEDS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGES<span class="token punctuation">)</span> -c <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token builtin">.PHONY</span><span class="token punctuation">:</span>clean<span class="token symbol">clean</span><span class="token punctuation">:</span>    <span class="token operator">@</span>rm -rf <span class="token variable">$</span><span class="token punctuation">(</span>OBJECT<span class="token punctuation">)</span> output/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分析：</p><ul><li>行 1：获取当前目录下 src 所有.c 文件，并赋值给变量 SOURCE。</li><li>行 2：将./src 目录下的.c 结尾的文件，替换成.o 文件，并赋值给变量OBJECT。</li><li>行 4：通过-I 选项指明头文件的目录，并赋值给变量 INCLUDES。</li><li>行 6：最终目标文件的名字 100ask，赋值给 TARGET。</li><li>行 7：替换 CC 的默认之 cc，改为 gcc。</li><li>行 8：将显示所有的警告信息选项和 gdb 调试选项赋值给变量 CFLAGS。</li><li>行 11：创建目录 output，并且不再终端现实该条命令。</li><li>行 12：编译生成可执行程序 100ask，并将可执行程序生成到 output 目录</li><li>行 15：将源文件生成对应的目标文件。</li><li>行 17：伪目标，避免当前目录有同名的 clean 文件。</li><li>行 19：用与执行命令 make clean 时执行的命令，删除编译过程生成的文件。 最后编译的结果，如下:</li></ul><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">make</span>gcc -I ./inc -c src/main.c -o src/main.ogcc -I ./inc -c src/add.c -o src/add.ogcc -I ./inc -c src/sub.c -o src/sub.ogcc src/main.o src/add.o src/sub.o -o output/100ask<span class="token variable">$tree</span><span class="token keyword">.</span>├── inc│ ├── add.h│ └── sub.h├── Makefile├── output│ └── 100ask└── src    ├── add.c    ├── add.o    ├── main.c    ├── main.o    ├── sub.c    └── sub.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的 Makefile 文件算是比较完善了，不过项目开发中，代码需要不断的迭代，那么必须要有东西来记录它的变化，所以还需要对最终的可执行文件添加版本号，如下：</p><pre class="line-numbers language-makefile"><code class="language-makefile">VERSION <span class="token operator">=</span> 1.0.0SOURCE <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">wildcard</span> ./src/*.c<span class="token punctuation">)</span>OBJECT <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">patsubst</span> %.c, %.o, <span class="token variable">$</span><span class="token punctuation">(</span>SOURCE<span class="token punctuation">)</span><span class="token punctuation">)</span>INCLUEDS <span class="token operator">=</span> -I ./incTARGET <span class="token operator">=</span> 100askCC <span class="token operator">=</span> gccCFLAGS <span class="token operator">=</span> -Wall -g<span class="token symbol"><span class="token variable">$</span>(TARGET)</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>OBJECT<span class="token punctuation">)</span>    <span class="token operator">@</span>mkdir -p output/    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$^</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGES<span class="token punctuation">)</span> -o output/<span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span>_<span class="token variable">$</span><span class="token punctuation">(</span>VERSION<span class="token punctuation">)</span><span class="token symbol">%.o</span><span class="token punctuation">:</span> %.c    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>INCLUEDS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGES<span class="token punctuation">)</span> -c <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token builtin">.PHONY</span><span class="token punctuation">:</span>clean<span class="token symbol">clean</span><span class="token punctuation">:</span>    <span class="token operator">@</span>rm -rf <span class="token variable">$</span><span class="token punctuation">(</span>OBJECT<span class="token punctuation">)</span> output/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>行 1：将版本号赋值给变量 VERSION。</li><li>行 13：生成可执行文件的后缀添加版本号。</li></ul><p>编译结果：</p><pre class="line-numbers language-text"><code class="language-text">$ tree.├── inc│ ├── add.h│ └── sub.h├── Makefile├── output│ └── 100ask_1.0.0└── src    ├── add.c        ├── add.o    ├── main.c    ├── main.o    ├── sub.c    └── sub.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>03-OLED和中断</title>
      <link href="/2024/12/19/03-oled-he-zhong-duan/"/>
      <url>/2024/12/19/03-oled-he-zhong-duan/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="STM32入门教程（江协）"><a href="#STM32入门教程（江协）" class="headerlink" title="STM32入门教程（江协）"></a>STM32入门教程（江协）</h1><h2 id="4-1-OLED调试工具"><a href="#4-1-OLED调试工具" class="headerlink" title="4-1 OLED调试工具"></a>4-1 OLED调试工具</h2><h3 id="调试方法"><a href="#调试方法" class="headerlink" title="调试方法"></a>调试方法</h3><ul><li>串口调试：通过串口通信，将调试信息发送到电脑端，电脑使用串口助手显示调试信息</li><li>显示屏调试：直接将显示屏连接到单片机，将调试信息打印在显示屏上</li><li>Keil调试模式：借助Keil软件的调试模式，可使用单步运行、设置断点、查看寄存器及变量等功能</li></ul><h3 id="OLED简介"><a href="#OLED简介" class="headerlink" title="OLED简介"></a>OLED简介</h3><ul><li>OLED（Organic Light Emitting Diode）：有机发光二极管</li><li>OLED显示屏：性能优异的新型显示屏，具有功耗低、相应速度快、宽视角、轻薄柔韧等特点</li><li>0.96寸OLED模块：小巧玲珑、占用接口少、简单易用，是电子设计中非常常见的显示屏模块</li><li>供电：3~5.5V，通信协议：I2C/SPI，分辨率：128*6</li></ul><p>硬件电路：</p><p><img src="https://pic.imgdb.cn/item/67627fead0e0a243d4e5bb77.png"></p><h3 id="OLED驱动函数"><a href="#OLED驱动函数" class="headerlink" title="OLED驱动函数"></a>OLED驱动函数</h3><table><thead><tr><th><strong>函数</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>OLED_Init();</td><td>初始化</td></tr><tr><td>OLED_Clear();</td><td>清屏</td></tr><tr><td>OLED_ShowChar(1, 1, ‘A’);</td><td>显示一个字符</td></tr><tr><td>OLED_ShowString(1, 3, “HelloWorld!”);</td><td>显示字符串</td></tr><tr><td>OLED_ShowNum(2, 1, 12345, 5);</td><td>显示十进制数字</td></tr><tr><td>OLED_ShowSignedNum(2, 7, -66, 2);</td><td>显示有符号十进制数字</td></tr><tr><td>OLED_ShowHexNum(3, 1, 0xAA55, 4);</td><td>显示十六进制数字</td></tr><tr><td>OLED_ShowBinNum(4, 1, 0xAA55, 16);</td><td>显示二进制数字</td></tr></tbody></table><h2 id="4-2-OLED显示屏"><a href="#4-2-OLED显示屏" class="headerlink" title="4-2 OLED显示屏"></a>4-2 OLED显示屏</h2><blockquote><p>接线图：<a href="https://github.com/404djl/stm32_source/blob/main/1-1%20%E6%8E%A5%E7%BA%BF%E5%9B%BE/4-1%20OLED%E6%98%BE%E7%A4%BA%E5%B1%8F.jpg" target="_blank" rel="noopener">https://github.com/404djl/stm32_source/blob/main/1-1%20%E6%8E%A5%E7%BA%BF%E5%9B%BE/4-1%20OLED%E6%98%BE%E7%A4%BA%E5%B1%8F.jpg</a></p><p>在Hardware目录里添加<code>OLED.c OLED.h OLED_Font.h</code>：<a href="https://github.com/404djl/stm32_source/tree/main/1-4%20OLED%E9%A9%B1%E5%8A%A8%E5%87%BD%E6%95%B0%E6%A8%A1%E5%9D%97" target="_blank" rel="noopener">https://github.com/404djl/stm32_source/tree/main/1-4%20OLED%E9%A9%B1%E5%8A%A8%E5%87%BD%E6%95%B0%E6%A8%A1%E5%9D%97</a></p></blockquote><h2 id="5-1-EXTI外部中断"><a href="#5-1-EXTI外部中断" class="headerlink" title="5-1 EXTI外部中断"></a>5-1 EXTI外部中断</h2><h3 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h3><ol><li>中断：在主程序运行过程中，出现了特定的中断触发条件（中断源），使得CPU暂停当前正在运行的程序，转而去处理中断程序，处理完成后又返回原来被暂停的位置继续运行</li><li>中断优先级：当有多个中断源同时申请中断时，CPU会根据中断源的轻重缓急进行裁决，优先响应更加紧急的中断源</li><li>中断嵌套：当一个中断程序正在运行时，又有新的更高优先级的中断源申请中断，CPU再次暂停当前中断程序，转而去处理新的中断程序，处理完成后依次进行返回</li></ol><h3 id="STM32中断"><a href="#STM32中断" class="headerlink" title="STM32中断"></a>STM32中断</h3><ol><li>68个可屏蔽中断通道，包含EXTI、TIM、ADC、USART、SPI、I2C、RTC等多个外设</li><li>使用NVIC统一管理中断，每个中断通道都拥有16个可编程的优先等级，可对优先级进行分组，进一步设置抢占优先级和响应优先级</li></ol><p><code>STM32F10xxx</code>中断向量表（部分）</p><p><img src="https://pic.imgdb.cn/item/676379b7d0e0a243d4e635ff.png"></p><h3 id="NVIC"><a href="#NVIC" class="headerlink" title="NVIC"></a>NVIC</h3><ol><li><p>NVIC基本结构</p><p><img src="https://pic.imgdb.cn/item/67637b05d0e0a243d4e63642.png"></p></li><li><p>NVIC优先级分组</p><ul><li><p>NVIC的中断优先级由优先级寄存器的4位（0~15）决定，这4位可以进行切分，分为高n位的抢占优先级和低4-n位的响应优先级</p></li><li><p>抢占优先级高的可以中断嵌套，响应优先级高的可以优先排队，抢占优先级和响应优先级均相同的按中断号排队</p><table><thead><tr><th><strong>分组方式</strong></th><th><strong>抢占优先级</strong></th><th><strong>响应优先级</strong></th></tr></thead><tbody><tr><td>分组0</td><td>0位，取值为0</td><td>4位，取值为0~15</td></tr><tr><td>分组1</td><td>1位，取值为0~1</td><td>3位，取值为0~7</td></tr><tr><td>分组2</td><td>2位，取值为0~3</td><td>2位，取值为0~3</td></tr><tr><td>分组3</td><td>3位，取值为0~7</td><td>1位，取值为0~1</td></tr><tr><td>分组4</td><td>4位，取值为0~15</td><td>0位，取值为0</td></tr></tbody></table></li></ul></li></ol><h3 id="EXTI"><a href="#EXTI" class="headerlink" title="EXTI"></a>EXTI</h3><ol><li><p>EXTI简介</p><ul><li>EXTI（Extern Interrupt）外部中断</li><li>EXTI可以监测指定GPIO口的电平信号，当其指定的GPIO口产生电平变化时，EXTI将立即向NVIC发出中断申请，经过NVIC裁决后即可中断CPU主程序，使CPU执行EXTI对应的中断程序</li><li>支持的触发方式：上升沿/下降沿/双边沿/软件触发</li><li>支持的GPIO口：所有GPIO口，但相同的Pin不能同时触发中断</li><li>通道数：16个GPIO_Pin，外加PVD输出、RTC闹钟、USB唤醒、以太网</li><li>唤醒触发响应方式：中断响应/事件响应</li></ul></li><li><p>EXTI基本结构</p><p><img src="https://pic.imgdb.cn/item/67637c52d0e0a243d4e63677.png"></p></li><li><p>AFIO复用IO口</p><ul><li>AFIO主要用于引脚复用功能的选择和重定义</li><li>在STM32中，AFIO主要完成两个任务：复用功能引脚重映射、中断引脚选择（对于STMF1来说，中断引脚选择是必须的）</li></ul><p><img src="https://pic.imgdb.cn/item/67637cfcd0e0a243d4e63690.png"></p></li><li><p>EXTI框图</p><p><img src="https://pic.imgdb.cn/item/67637d33d0e0a243d4e6369a.png"></p></li></ol><h3 id="旋转编码器"><a href="#旋转编码器" class="headerlink" title="旋转编码器"></a>旋转编码器</h3><ol><li><p>介绍：</p><ul><li><p>旋转编码器：用来测量位置、速度或旋转方向的装置，当其旋转轴旋转时，其输出端可以输出与旋转速度和方向对应的方波信号，读取方波信号的频率和相位信息即可得知旋转轴的速度和方向</p></li><li><p>类型：机械触点式/霍尔传感器式/光栅式</p></li></ul></li><li><p>硬件电路：</p><p><img src="https://pic.imgdb.cn/item/67638020d0e0a243d4e6371a.png"></p></li><li><p>工作原理：</p><p><img src="https://pic.imgdb.cn/item/6763811dd0e0a243d4e63758.png"></p><p><img src="https://pic.imgdb.cn/item/6763806fd0e0a243d4e63726.png"></p><p>默认情况是高电平</p></li></ol><h2 id="5-2-对射式红外传感器计次-旋转编码器计次"><a href="#5-2-对射式红外传感器计次-旋转编码器计次" class="headerlink" title="5-2 对射式红外传感器计次&amp;旋转编码器计次"></a>5-2 对射式红外传感器计次&amp;旋转编码器计次</h2><h3 id="对射式红外传感器计次"><a href="#对射式红外传感器计次" class="headerlink" title="对射式红外传感器计次"></a>对射式红外传感器计次</h3><blockquote><p>在Hardware目录添加<code>CountSensor.c和CountSensor.h</code>文件</p><p>接线图：<a href="https://github.com/404djl/stm32_source/blob/main/1-1%20%E6%8E%A5%E7%BA%BF%E5%9B%BE/5-1%20%E5%AF%B9%E5%B0%84%E5%BC%8F%E7%BA%A2%E5%A4%96%E4%BC%A0%E6%84%9F%E5%99%A8%E8%AE%A1%E6%AC%A1.jpg" target="_blank" rel="noopener">https://github.com/404djl/stm32_source/blob/main/1-1%20%E6%8E%A5%E7%BA%BF%E5%9B%BE/5-1%20%E5%AF%B9%E5%B0%84%E5%BC%8F%E7%BA%A2%E5%A4%96%E4%BC%A0%E6%84%9F%E5%99%A8%E8%AE%A1%E6%AC%A1.jpg</a>  </p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// main.c</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"stm32f10x.h"</span>                  </span><span class="token comment" spellcheck="true">// Device header</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"Delay.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"OLED.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"CountSensor.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*模块初始化*/</span>    <span class="token function">OLED_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//OLED初始化</span>    <span class="token function">CountSensor_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//计数传感器初始化</span>        <span class="token comment" spellcheck="true">/*显示静态字符串*/</span>    <span class="token function">OLED_ShowString</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"Count:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//1行1列显示字符串Count:</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">OLED_ShowNum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token function">CountSensor_Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//OLED不断刷新显示CountSensor_Get的返回值</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// CountSensor.h</span><span class="token macro property">#<span class="token directive keyword">ifndef</span> __COUNT_SENSOR_H</span><span class="token macro property">#<span class="token directive keyword">define</span> __COUNT_SENSOR_H</span><span class="token keyword">void</span> <span class="token function">CountSensor_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>uint16_t <span class="token function">CountSensor_Get</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// CountSensor.c</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"stm32f10x.h"</span>                  </span><span class="token comment" spellcheck="true">// Device header</span>uint16_t CountSensor_Count<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//全局变量，用于计数</span><span class="token comment" spellcheck="true">/**  * 函    数：计数传感器初始化  * 参    数：无  * 返 回 值：无  */</span><span class="token keyword">void</span> <span class="token function">CountSensor_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*开启时钟*/</span>    <span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_GPIOB<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//开启GPIOB的时钟</span>    <span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_AFIO<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//开启AFIO的时钟，外部中断必须开启AFIO的时钟</span>        <span class="token comment" spellcheck="true">/*GPIO初始化*/</span>    GPIO_InitTypeDef GPIO_InitStructure<span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_IPU<span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> GPIO_Pin_14<span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span>    <span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将PB14引脚初始化为上拉输入</span>        <span class="token comment" spellcheck="true">/*AFIO选择中断引脚*/</span>    <span class="token function">GPIO_EXTILineConfig</span><span class="token punctuation">(</span>GPIO_PortSourceGPIOB<span class="token punctuation">,</span> GPIO_PinSource14<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将外部中断的14号线映射到GPIOB，即选择PB14为外部中断引脚</span>        <span class="token comment" spellcheck="true">/*EXTI初始化*/</span>    EXTI_InitTypeDef EXTI_InitStructure<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//定义结构体变量</span>    EXTI_InitStructure<span class="token punctuation">.</span>EXTI_Line <span class="token operator">=</span> EXTI_Line14<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//选择配置外部中断的14号线</span>    EXTI_InitStructure<span class="token punctuation">.</span>EXTI_LineCmd <span class="token operator">=</span> ENABLE<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//指定外部中断线使能</span>    EXTI_InitStructure<span class="token punctuation">.</span>EXTI_Mode <span class="token operator">=</span> EXTI_Mode_Interrupt<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//指定外部中断线为中断模式</span>    EXTI_InitStructure<span class="token punctuation">.</span>EXTI_Trigger <span class="token operator">=</span> EXTI_Trigger_Falling<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//指定外部中断线为下降沿触发</span>    <span class="token function">EXTI_Init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>EXTI_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将结构体变量交给EXTI_Init，配置EXTI外设</span>        <span class="token comment" spellcheck="true">/*NVIC中断分组*/</span>    <span class="token function">NVIC_PriorityGroupConfig</span><span class="token punctuation">(</span>NVIC_PriorityGroup_2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//配置NVIC为分组2</span>                                                                <span class="token comment" spellcheck="true">//即抢占优先级范围：0~3，响应优先级范围：0~3</span>                                                                <span class="token comment" spellcheck="true">//此分组配置在整个工程中仅需调用一次</span>                                                                <span class="token comment" spellcheck="true">//若有多个中断，可以把此代码放在main函数内，while循环之前</span>                                                                <span class="token comment" spellcheck="true">//若调用多次配置分组的代码，则后执行的配置会覆盖先执行的配置</span>        <span class="token comment" spellcheck="true">/*NVIC配置*/</span>    NVIC_InitTypeDef NVIC_InitStructure<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//定义结构体变量</span>    NVIC_InitStructure<span class="token punctuation">.</span>NVIC_IRQChannel <span class="token operator">=</span> EXTI15_10_IRQn<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//选择配置NVIC的EXTI15_10线</span>    NVIC_InitStructure<span class="token punctuation">.</span>NVIC_IRQChannelCmd <span class="token operator">=</span> ENABLE<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//指定NVIC线路使能</span>    NVIC_InitStructure<span class="token punctuation">.</span>NVIC_IRQChannelPreemptionPriority <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//指定NVIC线路的抢占优先级为1</span>    NVIC_InitStructure<span class="token punctuation">.</span>NVIC_IRQChannelSubPriority <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//指定NVIC线路的响应优先级为1</span>    <span class="token function">NVIC_Init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>NVIC_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将结构体变量交给NVIC_Init，配置NVIC外设</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**  * 函    数：获取计数传感器的计数值  * 参    数：无  * 返 回 值：计数值，范围：0~65535  */</span>uint16_t <span class="token function">CountSensor_Get</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> CountSensor_Count<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**  * 函    数：EXTI15_10外部中断函数  * 参    数：无  * 返 回 值：无  * 注意事项：此函数为中断函数，无需调用，中断触发后自动执行  *           函数名为预留的指定名称，可以从启动文件复制  *           请确保函数名正确，不能有任何差异，否则中断函数将不能进入  */</span><span class="token keyword">void</span> <span class="token function">EXTI15_10_IRQHandler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">EXTI_GetITStatus</span><span class="token punctuation">(</span>EXTI_Line14<span class="token punctuation">)</span> <span class="token operator">==</span> SET<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//判断是否是外部中断14号线触发的中断</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/*如果出现数据乱跳的现象，可再次判断引脚电平，以避免抖动*/</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">GPIO_ReadInputDataBit</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> GPIO_Pin_14<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            CountSensor_Count <span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//计数值自增一次</span>        <span class="token punctuation">}</span>        <span class="token function">EXTI_ClearITPendingBit</span><span class="token punctuation">(</span>EXTI_Line14<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//清除外部中断14号线的中断标志位</span>                                                    <span class="token comment" spellcheck="true">//中断标志位必须清除</span>                                                    <span class="token comment" spellcheck="true">//否则中断将连续不断地触发，导致主程序卡死</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="旋转编码器计次"><a href="#旋转编码器计次" class="headerlink" title="旋转编码器计次"></a>旋转编码器计次</h3><blockquote><p>在Hardware目录添加<code>Encoder.c和Encoder.h</code>文件</p><p>接线图：<a href="https://github.com/404djl/stm32_source/blob/main/1-1%20%E6%8E%A5%E7%BA%BF%E5%9B%BE/5-2%20%E6%97%8B%E8%BD%AC%E7%BC%96%E7%A0%81%E5%99%A8%E8%AE%A1%E6%AC%A1.jpg" target="_blank" rel="noopener">https://github.com/404djl/stm32_source/blob/main/1-1%20%E6%8E%A5%E7%BA%BF%E5%9B%BE/5-2%20%E6%97%8B%E8%BD%AC%E7%BC%96%E7%A0%81%E5%99%A8%E8%AE%A1%E6%AC%A1.jpg</a></p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// main.c</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"stm32f10x.h"</span>                  </span><span class="token comment" spellcheck="true">// Device header</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"Delay.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"OLED.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"Encoder.h"</span></span>int16_t Num<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//定义待被旋转编码器调节的变量</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*模块初始化*/</span>    <span class="token function">OLED_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//OLED初始化</span>    <span class="token function">Encoder_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//旋转编码器初始化</span>        <span class="token comment" spellcheck="true">/*显示静态字符串*/</span>    <span class="token function">OLED_ShowString</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"Num:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//1行1列显示字符串Num:</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Num <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">Encoder_Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取自上此调用此函数后，旋转编码器的增量值，并将增量值加到Num上</span>        <span class="token function">OLED_ShowSignedNum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> Num<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//显示Num</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// Encoder.h</span><span class="token macro property">#<span class="token directive keyword">ifndef</span> __ENCODER_H</span><span class="token macro property">#<span class="token directive keyword">define</span> __ENCODER_H</span><span class="token keyword">void</span> <span class="token function">Encoder_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>int16_t <span class="token function">Encoder_Get</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// Encoder.c</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"stm32f10x.h"</span>                  </span><span class="token comment" spellcheck="true">// Device header</span>int16_t Encoder_Count<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//全局变量，用于计数旋转编码器的增量值</span><span class="token comment" spellcheck="true">/**  * 函    数：旋转编码器初始化  * 参    数：无  * 返 回 值：无  */</span><span class="token keyword">void</span> <span class="token function">Encoder_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*开启时钟*/</span>    <span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_GPIOB<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//开启GPIOB的时钟</span>    <span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_AFIO<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//开启AFIO的时钟，外部中断必须开启AFIO的时钟</span>        <span class="token comment" spellcheck="true">/*GPIO初始化*/</span>    GPIO_InitTypeDef GPIO_InitStructure<span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_IPU<span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> GPIO_Pin_0 <span class="token operator">|</span> GPIO_Pin_1<span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span>    <span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将PB0和PB1引脚初始化为上拉输入</span>        <span class="token comment" spellcheck="true">/*AFIO选择中断引脚*/</span>    <span class="token function">GPIO_EXTILineConfig</span><span class="token punctuation">(</span>GPIO_PortSourceGPIOB<span class="token punctuation">,</span> GPIO_PinSource0<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将外部中断的0号线映射到GPIOB，即选择PB0为外部中断引脚</span>    <span class="token function">GPIO_EXTILineConfig</span><span class="token punctuation">(</span>GPIO_PortSourceGPIOB<span class="token punctuation">,</span> GPIO_PinSource1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将外部中断的1号线映射到GPIOB，即选择PB1为外部中断引脚</span>        <span class="token comment" spellcheck="true">/*EXTI初始化*/</span>    EXTI_InitTypeDef EXTI_InitStructure<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//定义结构体变量</span>    EXTI_InitStructure<span class="token punctuation">.</span>EXTI_Line <span class="token operator">=</span> EXTI_Line0 <span class="token operator">|</span> EXTI_Line1<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//选择配置外部中断的0号线和1号线</span>    EXTI_InitStructure<span class="token punctuation">.</span>EXTI_LineCmd <span class="token operator">=</span> ENABLE<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//指定外部中断线使能</span>    EXTI_InitStructure<span class="token punctuation">.</span>EXTI_Mode <span class="token operator">=</span> EXTI_Mode_Interrupt<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//指定外部中断线为中断模式</span>    EXTI_InitStructure<span class="token punctuation">.</span>EXTI_Trigger <span class="token operator">=</span> EXTI_Trigger_Falling<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//指定外部中断线为下降沿触发</span>    <span class="token function">EXTI_Init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>EXTI_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将结构体变量交给EXTI_Init，配置EXTI外设</span>        <span class="token comment" spellcheck="true">/*NVIC中断分组*/</span>    <span class="token function">NVIC_PriorityGroupConfig</span><span class="token punctuation">(</span>NVIC_PriorityGroup_2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//配置NVIC为分组2</span>                                                                <span class="token comment" spellcheck="true">//即抢占优先级范围：0~3，响应优先级范围：0~3</span>                                                                <span class="token comment" spellcheck="true">//此分组配置在整个工程中仅需调用一次</span>                                                                <span class="token comment" spellcheck="true">//若有多个中断，可以把此代码放在main函数内，while循环之前</span>                                                                <span class="token comment" spellcheck="true">//若调用多次配置分组的代码，则后执行的配置会覆盖先执行的配置</span>        <span class="token comment" spellcheck="true">/*NVIC配置*/</span>    NVIC_InitTypeDef NVIC_InitStructure<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//定义结构体变量</span>    NVIC_InitStructure<span class="token punctuation">.</span>NVIC_IRQChannel <span class="token operator">=</span> EXTI0_IRQn<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//选择配置NVIC的EXTI0线</span>    NVIC_InitStructure<span class="token punctuation">.</span>NVIC_IRQChannelCmd <span class="token operator">=</span> ENABLE<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//指定NVIC线路使能</span>    NVIC_InitStructure<span class="token punctuation">.</span>NVIC_IRQChannelPreemptionPriority <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//指定NVIC线路的抢占优先级为1</span>    NVIC_InitStructure<span class="token punctuation">.</span>NVIC_IRQChannelSubPriority <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//指定NVIC线路的响应优先级为1</span>    <span class="token function">NVIC_Init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>NVIC_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将结构体变量交给NVIC_Init，配置NVIC外设</span>    NVIC_InitStructure<span class="token punctuation">.</span>NVIC_IRQChannel <span class="token operator">=</span> EXTI1_IRQn<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//选择配置NVIC的EXTI1线</span>    NVIC_InitStructure<span class="token punctuation">.</span>NVIC_IRQChannelCmd <span class="token operator">=</span> ENABLE<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//指定NVIC线路使能</span>    NVIC_InitStructure<span class="token punctuation">.</span>NVIC_IRQChannelPreemptionPriority <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//指定NVIC线路的抢占优先级为1</span>    NVIC_InitStructure<span class="token punctuation">.</span>NVIC_IRQChannelSubPriority <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//指定NVIC线路的响应优先级为2</span>    <span class="token function">NVIC_Init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>NVIC_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将结构体变量交给NVIC_Init，配置NVIC外设</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**  * 函    数：旋转编码器获取增量值  * 参    数：无  * 返 回 值：自上此调用此函数后，旋转编码器的增量值  */</span>int16_t <span class="token function">Encoder_Get</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*使用Temp变量作为中继，目的是返回Encoder_Count后将其清零*/</span>    <span class="token comment" spellcheck="true">/*在这里，也可以直接返回Encoder_Count      但这样就不是获取增量值的操作方法了      也可以实现功能，只是思路不一样*/</span>    int16_t Temp<span class="token punctuation">;</span>    Temp <span class="token operator">=</span> Encoder_Count<span class="token punctuation">;</span>    Encoder_Count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> Temp<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**  * 函    数：EXTI0外部中断函数  * 参    数：无  * 返 回 值：无  * 注意事项：此函数为中断函数，无需调用，中断触发后自动执行  *           函数名为预留的指定名称，可以从启动文件复制  *           请确保函数名正确，不能有任何差异，否则中断函数将不能进入  */</span><span class="token keyword">void</span> <span class="token function">EXTI0_IRQHandler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">EXTI_GetITStatus</span><span class="token punctuation">(</span>EXTI_Line0<span class="token punctuation">)</span> <span class="token operator">==</span> SET<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//判断是否是外部中断0号线触发的中断</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/*如果出现数据乱跳的现象，可再次判断引脚电平，以避免抖动*/</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">GPIO_ReadInputDataBit</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> GPIO_Pin_0<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">GPIO_ReadInputDataBit</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> GPIO_Pin_1<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//PB0的下降沿触发中断，此时检测另一相PB1的电平，目的是判断旋转方向</span>            <span class="token punctuation">{</span>                Encoder_Count <span class="token operator">--</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//此方向定义为反转，计数变量自减</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">EXTI_ClearITPendingBit</span><span class="token punctuation">(</span>EXTI_Line0<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//清除外部中断0号线的中断标志位</span>                                                    <span class="token comment" spellcheck="true">//中断标志位必须清除</span>                                                    <span class="token comment" spellcheck="true">//否则中断将连续不断地触发，导致主程序卡死</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**  * 函    数：EXTI1外部中断函数  * 参    数：无  * 返 回 值：无  * 注意事项：此函数为中断函数，无需调用，中断触发后自动执行  *           函数名为预留的指定名称，可以从启动文件复制  *           请确保函数名正确，不能有任何差异，否则中断函数将不能进入  */</span><span class="token keyword">void</span> <span class="token function">EXTI1_IRQHandler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">EXTI_GetITStatus</span><span class="token punctuation">(</span>EXTI_Line1<span class="token punctuation">)</span> <span class="token operator">==</span> SET<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//判断是否是外部中断1号线触发的中断</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/*如果出现数据乱跳的现象，可再次判断引脚电平，以避免抖动*/</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">GPIO_ReadInputDataBit</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> GPIO_Pin_1<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">GPIO_ReadInputDataBit</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> GPIO_Pin_0<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//PB1的下降沿触发中断，此时检测另一相PB0的电平，目的是判断旋转方向</span>            <span class="token punctuation">{</span>                Encoder_Count <span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//此方向定义为正转，计数变量自增</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">EXTI_ClearITPendingBit</span><span class="token punctuation">(</span>EXTI_Line1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//清除外部中断1号线的中断标志位</span>                                                    <span class="token comment" spellcheck="true">//中断标志位必须清除</span>                                                    <span class="token comment" spellcheck="true">//否则中断将连续不断地触发，导致主程序卡死</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> OLED </tag>
            
            <tag> 中断 </tag>
            
            <tag> 旋转编码器 </tag>
            
            <tag> 对射式红外传感器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02-GPIO输出和输入</title>
      <link href="/2024/12/18/02-gpio-shu-chu-he-shu-ru/"/>
      <url>/2024/12/18/02-gpio-shu-chu-he-shu-ru/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="STM32入门教程（江协）"><a href="#STM32入门教程（江协）" class="headerlink" title="STM32入门教程（江协）"></a>STM32入门教程（江协）</h1><h2 id="3-1-GPIO输出"><a href="#3-1-GPIO输出" class="headerlink" title="3-1 GPIO输出"></a>3-1 GPIO输出</h2><ol><li><p>GPIO 简介</p><ul><li>GPIO（General Purpose Input Output）通用输入输出口</li><li>可配置为8种输入输出模式</li><li>引脚电平：0V~3.3V，部分引脚可容忍5V</li><li>输出模式下可控制端口输出高低电平，用以驱动LED、控制蜂鸣器、模拟通信协议输出时序等</li><li>输入模式下可读取端口的高低电平或电压，用于读取按键输入、外接模块电平信号输入、ADC电压采集、模拟通信协议接收数据等</li></ul></li><li><p>GPIO基本结构</p><p>全都挂载在APB2总线上，每个GPI/O端口有两个32位配置寄存器(GPIOx_CRL，GPIOx_CRH，<strong>4位配置一个端口</strong>)，两个32位数据寄存器(GPIOx_IDR和GPIOx_ODR，<strong>低16位有效</strong>)，一个32位置位/复位寄存器(GPIOx_BSRR，<strong>高16位进行位清除，低16位进行位设置</strong>)，一个16位复位寄存器(GPIOx_BRR，<strong>相当于GPIOx_BSRR的高16位</strong>，<strong>同步性要求不高的话可以使用</strong>)和一个32位锁定寄存器(GPIOx_LCKR)。</p><p><img src="https://pic.imgdb.cn/item/67617a2fd0e0a243d4e5843d.png"></p></li><li><p>GPIO位结构</p><p><img src="https://pic.imgdb.cn/item/67617b8ad0e0a243d4e584b2.png"></p><ul><li>保护二极管使得输入电压在0~3.3v之间</li><li>上拉（高电平）、下拉（低电平）、浮空</li><li>施密特触发器对输入电压进行整形：如果输入电压大于某一上阈值，输出就会瞬间升为高电平；如果输入电压小于某一下阈值，输出就会瞬间降为低电平；在两个阈值之间的会维持原有输出电压。能有效的避免信号产生的抖动。</li><li>经过施密特触发器整形的波形就可以直接写入输入数据寄存器了，再用程序读取输入数据寄存器对应某一位的数据，就能知道端口的输入电平了</li><li>模拟输入（连接到ADC上）；复用功能输入，可以接到其他需要读取端口的外设上的，比如串口的输入引脚等，这个线接收的是数字量，所以在施密特触发器后面</li><li>输出数字部分可以由输出数据寄存器或片上外设控制；位设置/清除寄存器可以用来单独操作输出数据寄存器的某一位，而不影响其它位。</li><li>在推挽输出模式下，P-MOS和N-MOS均有效，数据寄存器为1时，上管导通，下管断开，输出直接接到VDD，就是输出高电平；数据寄存器为0时，输出低电平；这种模式下，高低电平均有较强的驱动能力。</li><li>在开漏输出模式下，P-MOS是无效的，只有N-MOS在工作，数据寄存器为1时，下管断开，这时输出相当于断开，也就是高阻模式（开路）；数据寄存器为0时，下管导通，输出直接接到VSS，也就是输出低电平。这种模式下只有低电平有驱动能力，高电平是没有驱动能力的。I2C通信的引脚，就是使用的开漏模式，在多机通信的情况下，这个模式可以避免各个设备的相互干扰。该模式还可以输出5V的电平信号。</li><li>输出关闭时，用于输入。</li></ul></li><li><p>GPIO模式</p><table><thead><tr><th><strong>模式名称</strong></th><th><strong>性质</strong></th><th><strong>特征</strong></th></tr></thead><tbody><tr><td>浮空输入</td><td>数字输入</td><td>可读取引脚电平，若引脚悬空，则电平不确定</td></tr><tr><td>上拉输入</td><td>数字输入</td><td>可读取引脚电平，内部连接上拉电阻，悬空时默认高电平</td></tr><tr><td>下拉输入</td><td>数字输入</td><td>可读取引脚电平，内部连接下拉电阻，悬空时默认低电平</td></tr><tr><td>模拟输入</td><td>模拟输入</td><td>GPIO无效，引脚直接接入内部ADC</td></tr><tr><td>开漏输出</td><td>数字输出</td><td>可输出引脚电平，高电平为高阻态，低电平接VSS</td></tr><tr><td>推挽输出</td><td>数字输出</td><td>可输出引脚电平，高电平接VDD，低电平接VSS</td></tr><tr><td>复用开漏输出</td><td>数字输出</td><td>由片上外设控制，高电平为高阻态，低电平接VSS</td></tr><tr><td>复用推挽输出</td><td>数字输出</td><td>由片上外设控制，高电平接VDD，低电平接VSS</td></tr></tbody></table><blockquote><p>输入时，输出是断开的；输出时，也可以输入</p><p>GPIO的这8种模式中，出了模拟输入这个模式会关闭数字寄存器的输入功能，其他7个模式中，所有的输入都是有效的</p></blockquote></li><li><p>LED和蜂鸣器介绍</p><ul><li><p>LED：发光二极管，正向通电点亮，反向通电不亮；长引脚为正</p></li><li><p>有源蜂鸣器：内部自带振荡源，将正负极接上直流电压即可持续发声，频率固定。</p><p>2引脚接低电平，蜂鸣器发声，接高电平，蜂鸣器关闭。</p><p><img src="https://pic.imgdb.cn/item/676187e5d0e0a243d4e5882d.png"></p><p>高电平弱驱动、低电平强驱动</p></li></ul></li></ol><h2 id="3-2-LED闪烁-LED流水灯-蜂鸣器"><a href="#3-2-LED闪烁-LED流水灯-蜂鸣器" class="headerlink" title="3-2 LED闪烁&amp;LED流水灯&amp;蜂鸣器"></a>3-2 LED闪烁&amp;LED流水灯&amp;蜂鸣器</h2><h3 id="LED闪烁代码"><a href="#LED闪烁代码" class="headerlink" title="LED闪烁代码"></a>LED闪烁代码</h3><blockquote><p>新建一个System文件夹，用于存放Delay.c和Delay.h，头文件包含System目录；低电平驱动.</p><p>接线图：<a href="https://github.com/404djl/stm32_source/blob/main/1-1%20%E6%8E%A5%E7%BA%BF%E5%9B%BE/3-1%20LED%E9%97%AA%E7%83%81.jpg" target="_blank" rel="noopener">https://github.com/404djl/stm32_source/blob/main/1-1%20%E6%8E%A5%E7%BA%BF%E5%9B%BE/3-1%20LED%E9%97%AA%E7%83%81.jpg</a></p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"stm32f10x.h"</span>                  </span><span class="token comment" spellcheck="true">// Device header</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"Delay.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*开启时钟*/</span>    <span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_GPIOA<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//开启GPIOA的时钟</span>                                                            <span class="token comment" spellcheck="true">//使用各个外设前必须开启时钟，否则对外设的操作无效</span>        <span class="token comment" spellcheck="true">/*GPIO初始化*/</span>    GPIO_InitTypeDef GPIO_InitStructure<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//定义结构体变量</span>        GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_Out_PP<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//GPIO模式，赋值为推挽输出模式</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> GPIO_Pin_0<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//GPIO引脚，赋值为第0号引脚</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//GPIO速度，赋值为50MHz</span>        <span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将赋值后的构体变量传递给GPIO_Init函数</span>                                                            <span class="token comment" spellcheck="true">//函数内部会自动根据结构体的参数配置相应寄存器</span>                                                            <span class="token comment" spellcheck="true">//实现GPIOA的初始化</span>        <span class="token comment" spellcheck="true">/*主循环，循环体内的代码会一直循环执行*/</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/*设置PA0引脚的高低电平，实现LED闪烁，下面展示3种方法*/</span>                <span class="token comment" spellcheck="true">/*方法1：GPIO_ResetBits设置低电平，GPIO_SetBits设置高电平*/</span>        <span class="token function">GPIO_ResetBits</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> GPIO_Pin_0<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将PA0引脚设置为低电平</span>        <span class="token function">Delay_ms</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//延时500ms</span>        <span class="token function">GPIO_SetBits</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> GPIO_Pin_0<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将PA0引脚设置为高电平</span>        <span class="token function">Delay_ms</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//延时500ms</span>                <span class="token comment" spellcheck="true">/*方法2：GPIO_WriteBit设置低/高电平，由Bit_RESET/Bit_SET指定*/</span>        <span class="token function">GPIO_WriteBit</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> GPIO_Pin_0<span class="token punctuation">,</span> Bit_RESET<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将PA0引脚设置为低电平</span>        <span class="token function">Delay_ms</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//延时500ms</span>        <span class="token function">GPIO_WriteBit</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> GPIO_Pin_0<span class="token punctuation">,</span> Bit_SET<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将PA0引脚设置为高电平</span>        <span class="token function">Delay_ms</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//延时500ms</span>                <span class="token comment" spellcheck="true">/*方法3：GPIO_WriteBit设置低/高电平，由数据0/1指定，数据需要强转为BitAction类型*/</span>        <span class="token function">GPIO_WriteBit</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> GPIO_Pin_0<span class="token punctuation">,</span> <span class="token punctuation">(</span>BitAction<span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将PA0引脚设置为低电平</span>        <span class="token function">Delay_ms</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//延时500ms</span>        <span class="token function">GPIO_WriteBit</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> GPIO_Pin_0<span class="token punctuation">,</span> <span class="token punctuation">(</span>BitAction<span class="token punctuation">)</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将PA0引脚设置为高电平</span>        <span class="token function">Delay_ms</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//延时500ms</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="LED流水灯"><a href="#LED流水灯" class="headerlink" title="LED流水灯"></a>LED流水灯</h3><blockquote><p>接线图：<a href="https://github.com/404djl/stm32_source/blob/main/1-1%20%E6%8E%A5%E7%BA%BF%E5%9B%BE/3-2%20LED%E6%B5%81%E6%B0%B4%E7%81%AF.jpg" target="_blank" rel="noopener">https://github.com/404djl/stm32_source/blob/main/1-1%20%E6%8E%A5%E7%BA%BF%E5%9B%BE/3-2%20LED%E6%B5%81%E6%B0%B4%E7%81%AF.jpg</a></p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"stm32f10x.h"</span>                  </span><span class="token comment" spellcheck="true">// Device header</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"Delay.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*开启时钟*/</span>    <span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_GPIOA<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//开启GPIOA的时钟</span>                                                            <span class="token comment" spellcheck="true">//使用各个外设前必须开启时钟，否则对外设的操作无效</span>        <span class="token comment" spellcheck="true">/*GPIO初始化*/</span>    GPIO_InitTypeDef GPIO_InitStructure<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//定义结构体变量</span>        GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_Out_PP<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//GPIO模式，赋值为推挽输出模式</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> GPIO_Pin_All<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//GPIO引脚，赋值为所有引脚</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//GPIO速度，赋值为50MHz</span>        <span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将赋值后的构体变量传递给GPIO_Init函数</span>                                                            <span class="token comment" spellcheck="true">//函数内部会自动根据结构体的参数配置相应寄存器</span>                                                            <span class="token comment" spellcheck="true">//实现GPIOA的初始化</span>        <span class="token comment" spellcheck="true">/*主循环，循环体内的代码会一直循环执行*/</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/*使用GPIO_Write，同时设置GPIOA所有引脚的高低电平，实现LED流水灯*/</span>        <span class="token function">GPIO_Write</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">~</span><span class="token number">0x0001</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//0000 0000 0000 0001，PA0引脚为低电平，其他引脚均为高电平，注意数据有按位取反</span>        <span class="token function">Delay_ms</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//延时100ms</span>        <span class="token function">GPIO_Write</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">~</span><span class="token number">0x0002</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//0000 0000 0000 0010，PA1引脚为低电平，其他引脚均为高电平</span>        <span class="token function">Delay_ms</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//延时100ms</span>        <span class="token function">GPIO_Write</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">~</span><span class="token number">0x0004</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//0000 0000 0000 0100，PA2引脚为低电平，其他引脚均为高电平</span>        <span class="token function">Delay_ms</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//延时100ms</span>        <span class="token function">GPIO_Write</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">~</span><span class="token number">0x0008</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//0000 0000 0000 1000，PA3引脚为低电平，其他引脚均为高电平</span>        <span class="token function">Delay_ms</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//延时100ms</span>        <span class="token function">GPIO_Write</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">~</span><span class="token number">0x0010</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//0000 0000 0001 0000，PA4引脚为低电平，其他引脚均为高电平</span>        <span class="token function">Delay_ms</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//延时100ms</span>        <span class="token function">GPIO_Write</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">~</span><span class="token number">0x0020</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//0000 0000 0010 0000，PA5引脚为低电平，其他引脚均为高电平</span>        <span class="token function">Delay_ms</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//延时100ms</span>        <span class="token function">GPIO_Write</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">~</span><span class="token number">0x0040</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//0000 0000 0100 0000，PA6引脚为低电平，其他引脚均为高电平</span>        <span class="token function">Delay_ms</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//延时100ms</span>        <span class="token function">GPIO_Write</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">~</span><span class="token number">0x0080</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//0000 0000 1000 0000，PA7引脚为低电平，其他引脚均为高电平</span>        <span class="token function">Delay_ms</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//延时100ms</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="蜂鸣器"><a href="#蜂鸣器" class="headerlink" title="蜂鸣器"></a>蜂鸣器</h3><blockquote><p>选择PB12端口，低电平驱动；不要选A15、B3、B4(为JTAG调试端口)</p><p><a href="https://github.com/404djl/stm32_source/blob/main/1-1%20%E6%8E%A5%E7%BA%BF%E5%9B%BE/3-3%20%E8%9C%82%E9%B8%A3%E5%99%A8.jpg" target="_blank" rel="noopener">https://github.com/404djl/stm32_source/blob/main/1-1%20%E6%8E%A5%E7%BA%BF%E5%9B%BE/3-3%20%E8%9C%82%E9%B8%A3%E5%99%A8.jpg</a></p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"stm32f10x.h"</span>                  </span><span class="token comment" spellcheck="true">// Device header</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"Delay.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*开启时钟*/</span>    <span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_GPIOB<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//开启GPIOB的时钟</span>                                                            <span class="token comment" spellcheck="true">//使用各个外设前必须开启时钟，否则对外设的操作无效</span>        <span class="token comment" spellcheck="true">/*GPIO初始化*/</span>    GPIO_InitTypeDef GPIO_InitStructure<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//定义结构体变量</span>        GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_Out_PP<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//GPIO模式，赋值为推挽输出模式</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> GPIO_Pin_12<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//GPIO引脚，赋值为第12号引脚</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//GPIO速度，赋值为50MHz</span>        <span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将赋值后的构体变量传递给GPIO_Init函数</span>                                                            <span class="token comment" spellcheck="true">//函数内部会自动根据结构体的参数配置相应寄存器</span>                                                            <span class="token comment" spellcheck="true">//实现GPIOB的初始化</span>        <span class="token comment" spellcheck="true">/*主循环，循环体内的代码会一直循环执行*/</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">GPIO_ResetBits</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> GPIO_Pin_12<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将PB12引脚设置为低电平，蜂鸣器鸣叫</span>        <span class="token function">Delay_ms</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//延时100ms</span>        <span class="token function">GPIO_SetBits</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> GPIO_Pin_12<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将PB12引脚设置为高电平，蜂鸣器停止</span>        <span class="token function">Delay_ms</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//延时100ms</span>        <span class="token function">GPIO_ResetBits</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> GPIO_Pin_12<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将PB12引脚设置为低电平，蜂鸣器鸣叫</span>        <span class="token function">Delay_ms</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//延时100ms</span>        <span class="token function">GPIO_SetBits</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> GPIO_Pin_12<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将PB12引脚设置为高电平，蜂鸣器停止</span>        <span class="token function">Delay_ms</span><span class="token punctuation">(</span><span class="token number">700</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//延时700ms</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>补充：不懂的库函数可以参考“<strong>STM32F103xx固件函数库用户手册</strong>”</p></blockquote><h2 id="3-3-GPIO输入"><a href="#3-3-GPIO输入" class="headerlink" title="3-3 GPIO输入"></a>3-3 GPIO输入</h2><ol><li><p>按键介绍</p><ul><li>常见的输入设备，按下导通，松手断开</li><li>按键抖动：由于按键内部使用的是机械式弹簧片来进行通断的，所以在按下和松手的瞬间会伴随有一连串的抖动。可以通过前后延时来进行消抖。</li></ul></li><li><p>传感器模块简介</p><p>传感器模块：传感器元件（光敏电阻/热敏电阻/红外接收管等）的电阻会随外界模拟量的变化而变化，通过与定值电阻分压即可得到模拟电压输出，再通过电压比较器进行二值化即可得到数字电压输出。</p><p><img src="https://pic.imgdb.cn/item/67622d02d0e0a243d4e5982d.png"></p></li><li><p>硬件电路</p><p><img src="https://pic.imgdb.cn/item/67622dccd0e0a243d4e59858.png"></p></li><li><p>C语言数据类型</p><table><thead><tr><th><strong>关键字</strong></th><th><strong>位数</strong></th><th><strong>表示范围</strong></th><th><strong>stdint****关键字</strong></th><th><strong>ST****关键字</strong></th></tr></thead><tbody><tr><td>char</td><td>8</td><td>-128 ~ 127</td><td>int8_t</td><td>s8</td></tr><tr><td>unsigned char</td><td>8</td><td>0 ~ 255</td><td>uint8_t</td><td>u8</td></tr><tr><td>short</td><td>16</td><td>-32768 ~ 32767</td><td>int16_t</td><td>s16</td></tr><tr><td>unsigned short</td><td>16</td><td>0 ~ 65535</td><td>uint16_t</td><td>u16</td></tr><tr><td>int</td><td>32</td><td>-2147483648 ~ 2147483647</td><td>int32_t</td><td>s32</td></tr><tr><td>unsigned int</td><td>32</td><td>0 ~ 4294967295</td><td>uint32_t</td><td>u32</td></tr><tr><td>long</td><td>32</td><td>-2147483648 ~ 2147483647</td><td></td><td></td></tr><tr><td>unsigned long</td><td>32</td><td>0 ~ 4294967295</td><td></td><td></td></tr><tr><td>long long</td><td>64</td><td>-(2^64)/2 ~ (2^64)/2-1</td><td>int64_t</td><td></td></tr><tr><td>unsigned long long</td><td>64</td><td>0 ~ (2^64)-1</td><td>uint64_t</td><td></td></tr><tr><td>float</td><td>32</td><td>-3.4e38 ~ 3.4e38</td><td></td><td></td></tr><tr><td>double</td><td>64</td><td>-1.7e308 ~ 1.7e308</td><td></td><td></td></tr></tbody></table></li><li><p>C语言宏定义</p><ul><li>关键字：#define</li><li>用途：用一个字符串代替一个数字，便于理解，防止出错；提取程序中经常出现的参数，便于快速修改</li><li>定义宏定义：#define ABC 12345</li><li>引用宏定义：int a = ABC;//等效于int a = 12345;</li></ul></li><li><p>C语言typedef</p><ul><li>关键字：typedef</li><li>用途：将一个比较长的变量类型名换个名字，便于使用</li><li>定义typedef：typedef unsigned char uint8_t;</li><li>引用typedef： uint8_t a;//等效于unsigned char a;</li></ul></li><li><p>C语言结构体</p><pre class="line-numbers language-c"><code class="language-c">关键字：<span class="token keyword">struct</span>用途：数据打包，不同类型变量的集合定义结构体变量：    <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token keyword">char</span> x<span class="token punctuation">;</span> <span class="token keyword">int</span> y<span class="token punctuation">;</span> <span class="token keyword">float</span> z<span class="token punctuation">;</span><span class="token punctuation">}</span> StructName<span class="token punctuation">;</span>    因为结构体变量类型较长，所以通常用<span class="token keyword">typedef</span>更改变量类型名引用结构体成员：    StructName<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token string">'A'</span><span class="token punctuation">;</span>    StructName<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">66</span><span class="token punctuation">;</span>    StructName<span class="token punctuation">.</span>z <span class="token operator">=</span> <span class="token number">1.23</span><span class="token punctuation">;</span>或pStructName<span class="token operator">-></span>x <span class="token operator">=</span> <span class="token string">'A'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//pStructName为结构体的地址pStructName->y = 66;</span>    pStructName<span class="token operator">-></span>z <span class="token operator">=</span> <span class="token number">1.23</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>C语言枚举</p><pre class="line-numbers language-c"><code class="language-c">关键字：<span class="token keyword">enum</span>用途：定义一个取值受限制的整型变量，用于限制变量取值范围；宏定义的集合定义枚举变量：    <span class="token keyword">enum</span><span class="token punctuation">{</span>FALSE <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> TRUE <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">}</span> EnumName<span class="token punctuation">;</span>    因为枚举变量类型较长，所以通常用<span class="token keyword">typedef</span>更改变量类型名引用枚举成员：    EnumName <span class="token operator">=</span> FALSE<span class="token punctuation">;</span>    EnumName <span class="token operator">=</span> TRUE<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="3-4-按键控制LED-光敏传感器控制蜂鸣器"><a href="#3-4-按键控制LED-光敏传感器控制蜂鸣器" class="headerlink" title="3-4 按键控制LED&amp;光敏传感器控制蜂鸣器"></a>3-4 按键控制LED&amp;光敏传感器控制蜂鸣器</h2><h3 id="按键控制LED"><a href="#按键控制LED" class="headerlink" title="按键控制LED"></a>按键控制LED</h3><blockquote><p>新增了Hardware目录，包含<code>LED.h、LED.c、Key.h、Key.c</code>，在Keil里增加Hardware组，头文件包含该目录</p><p>接线图：<a href="https://github.com/404djl/stm32_source/blob/main/1-1%20%E6%8E%A5%E7%BA%BF%E5%9B%BE/3-4%20%E6%8C%89%E9%94%AE%E6%8E%A7%E5%88%B6LED.jpg" target="_blank" rel="noopener">https://github.com/404djl/stm32_source/blob/main/1-1%20%E6%8E%A5%E7%BA%BF%E5%9B%BE/3-4%20%E6%8C%89%E9%94%AE%E6%8E%A7%E5%88%B6LED.jpg</a></p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// main.c</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"stm32f10x.h"</span>                  </span><span class="token comment" spellcheck="true">// Device header</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"Delay.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"LED.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"Key.h"</span></span>uint8_t KeyNum<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//定义用于接收按键键码的变量</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*模块初始化*/</span>    <span class="token function">LED_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//LED初始化</span>    <span class="token function">Key_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//按键初始化</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        KeyNum <span class="token operator">=</span> <span class="token function">Key_GetNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取按键键码</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>KeyNum <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//按键1按下</span>        <span class="token punctuation">{</span>            <span class="token function">LED1_Turn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//LED1翻转</span>        <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>KeyNum <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//按键2按下</span>        <span class="token punctuation">{</span>            <span class="token function">LED2_Turn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//LED2翻转</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// LED.h</span><span class="token macro property">#<span class="token directive keyword">ifndef</span> __LED_H</span><span class="token macro property">#<span class="token directive keyword">define</span> __LED_H</span><span class="token keyword">void</span> <span class="token function">LED_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">LED1_ON</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">LED1_OFF</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">LED1_Turn</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">LED2_ON</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">LED2_OFF</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">LED2_Turn</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// LED.c</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"stm32f10x.h"</span>                  </span><span class="token comment" spellcheck="true">// Device header</span><span class="token comment" spellcheck="true">/**  * 函    数：LED初始化  * 参    数：无  * 返 回 值：无  */</span><span class="token keyword">void</span> <span class="token function">LED_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*开启时钟*/</span>    <span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_GPIOA<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//开启GPIOA的时钟</span>        <span class="token comment" spellcheck="true">/*GPIO初始化*/</span>    GPIO_InitTypeDef GPIO_InitStructure<span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_Out_PP<span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> GPIO_Pin_1 <span class="token operator">|</span> GPIO_Pin_2<span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span>    <span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将PA1和PA2引脚初始化为推挽输出</span>        <span class="token comment" spellcheck="true">/*设置GPIO初始化后的默认电平*/</span>    <span class="token function">GPIO_SetBits</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> GPIO_Pin_1 <span class="token operator">|</span> GPIO_Pin_2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置PA1和PA2引脚为高电平</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**  * 函    数：LED1开启  * 参    数：无  * 返 回 值：无  */</span><span class="token keyword">void</span> <span class="token function">LED1_ON</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">GPIO_ResetBits</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> GPIO_Pin_1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置PA1引脚为低电平</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**  * 函    数：LED1关闭  * 参    数：无  * 返 回 值：无  */</span><span class="token keyword">void</span> <span class="token function">LED1_OFF</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">GPIO_SetBits</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> GPIO_Pin_1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置PA1引脚为高电平</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**  * 函    数：LED1状态翻转  * 参    数：无  * 返 回 值：无  */</span><span class="token keyword">void</span> <span class="token function">LED1_Turn</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">GPIO_ReadOutputDataBit</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> GPIO_Pin_1<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//获取输出寄存器的状态，如果当前引脚输出低电平</span>    <span class="token punctuation">{</span>        <span class="token function">GPIO_SetBits</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> GPIO_Pin_1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//则设置PA1引脚为高电平</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span><span class="token comment" spellcheck="true">//否则，即当前引脚输出高电平</span>    <span class="token punctuation">{</span>        <span class="token function">GPIO_ResetBits</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> GPIO_Pin_1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//则设置PA1引脚为低电平</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**  * 函    数：LED2开启  * 参    数：无  * 返 回 值：无  */</span><span class="token keyword">void</span> <span class="token function">LED2_ON</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">GPIO_ResetBits</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> GPIO_Pin_2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置PA2引脚为低电平</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**  * 函    数：LED2关闭  * 参    数：无  * 返 回 值：无  */</span><span class="token keyword">void</span> <span class="token function">LED2_OFF</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">GPIO_SetBits</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> GPIO_Pin_2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置PA2引脚为高电平</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**  * 函    数：LED2状态翻转  * 参    数：无  * 返 回 值：无  */</span><span class="token keyword">void</span> <span class="token function">LED2_Turn</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">GPIO_ReadOutputDataBit</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> GPIO_Pin_2<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//获取输出寄存器的状态，如果当前引脚输出低电平</span>    <span class="token punctuation">{</span>                                                          <span class="token function">GPIO_SetBits</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> GPIO_Pin_2<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">//则设置PA2引脚为高电平</span>    <span class="token punctuation">}</span>                                                      <span class="token keyword">else</span>                                               <span class="token comment" spellcheck="true">//否则，即当前引脚输出高电平</span>    <span class="token punctuation">{</span>                                                          <span class="token function">GPIO_ResetBits</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> GPIO_Pin_2<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//则设置PA2引脚为低电平</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// Key.h</span><span class="token macro property">#<span class="token directive keyword">ifndef</span> __KEY_H</span><span class="token macro property">#<span class="token directive keyword">define</span> __KEY_H</span><span class="token keyword">void</span> <span class="token function">Key_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>uint8_t <span class="token function">Key_GetNum</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// key.c</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"stm32f10x.h"</span>                  </span><span class="token comment" spellcheck="true">// Device header</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"Delay.h"</span></span><span class="token comment" spellcheck="true">/**  * 函    数：按键初始化  * 参    数：无  * 返 回 值：无  */</span><span class="token keyword">void</span> <span class="token function">Key_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*开启时钟*/</span>    <span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_GPIOB<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//开启GPIOB的时钟</span>        <span class="token comment" spellcheck="true">/*GPIO初始化*/</span>    GPIO_InitTypeDef GPIO_InitStructure<span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_IPU<span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> GPIO_Pin_1 <span class="token operator">|</span> GPIO_Pin_11<span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span>    <span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将PB1和PB11引脚初始化为上拉输入</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**  * 函    数：按键获取键码  * 参    数：无  * 返 回 值：按下按键的键码值，范围：0~2，返回0代表没有按键按下  * 注意事项：此函数是阻塞式操作，当按键按住不放时，函数会卡住，直到按键松手  */</span>uint8_t <span class="token function">Key_GetNum</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    uint8_t KeyNum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//定义变量，默认键码值为0</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">GPIO_ReadInputDataBit</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> GPIO_Pin_1<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//读PB1输入寄存器的状态，如果为0，则代表按键1按下</span>    <span class="token punctuation">{</span>        <span class="token function">Delay_ms</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//延时消抖</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">GPIO_ReadInputDataBit</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> GPIO_Pin_1<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//等待按键松手</span>        <span class="token function">Delay_ms</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//延时消抖</span>        KeyNum <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//置键码为1</span>    <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">GPIO_ReadInputDataBit</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> GPIO_Pin_11<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//读PB11输入寄存器的状态，如果为0，则代表按键2按下</span>    <span class="token punctuation">{</span>        <span class="token function">Delay_ms</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//延时消抖</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">GPIO_ReadInputDataBit</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> GPIO_Pin_11<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//等待按键松手</span>        <span class="token function">Delay_ms</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//延时消抖</span>        KeyNum <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//置键码为2</span>    <span class="token punctuation">}</span>        <span class="token keyword">return</span> KeyNum<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//返回键码值，如果没有按键按下，所有if都不成立，则键码为默认值0</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="光敏传感器控制蜂鸣器"><a href="#光敏传感器控制蜂鸣器" class="headerlink" title="光敏传感器控制蜂鸣器"></a>光敏传感器控制蜂鸣器</h3><blockquote><p>在Hardware目录添加<code>Buzzer.h、Buzzer.c、LightSensor.h、LightSensor.c</code>文件</p><p>接线图：<a href="https://github.com/404djl/stm32_source/blob/main/1-1%20%E6%8E%A5%E7%BA%BF%E5%9B%BE/3-5%20%E5%85%89%E6%95%8F%E4%BC%A0%E6%84%9F%E5%99%A8%E6%8E%A7%E5%88%B6%E8%9C%82%E9%B8%A3%E5%99%A8.jpg" target="_blank" rel="noopener">https://github.com/404djl/stm32_source/blob/main/1-1%20%E6%8E%A5%E7%BA%BF%E5%9B%BE/3-5%20%E5%85%89%E6%95%8F%E4%BC%A0%E6%84%9F%E5%99%A8%E6%8E%A7%E5%88%B6%E8%9C%82%E9%B8%A3%E5%99%A8.jpg</a></p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// main.c</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"stm32f10x.h"</span>                  </span><span class="token comment" spellcheck="true">// Device header</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"Delay.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"Buzzer.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"LightSensor.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*模块初始化*/</span>    <span class="token function">Buzzer_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//蜂鸣器初始化</span>    <span class="token function">LightSensor_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//光敏传感器初始化</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">LightSensor_Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//如果当前光敏输出1</span>        <span class="token punctuation">{</span>            <span class="token function">Buzzer_ON</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//蜂鸣器开启</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span><span class="token comment" spellcheck="true">//否则</span>        <span class="token punctuation">{</span>            <span class="token function">Buzzer_OFF</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//蜂鸣器关闭</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// Buzzer.h</span><span class="token macro property">#<span class="token directive keyword">ifndef</span> __BUZZER_H</span><span class="token macro property">#<span class="token directive keyword">define</span> __BUZZER_H</span><span class="token keyword">void</span> <span class="token function">Buzzer_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">Buzzer_ON</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">Buzzer_OFF</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">Buzzer_Turn</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// Buzzer.c</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"stm32f10x.h"</span>                  </span><span class="token comment" spellcheck="true">// Device header</span><span class="token comment" spellcheck="true">/**  * 函    数：蜂鸣器初始化  * 参    数：无  * 返 回 值：无  */</span><span class="token keyword">void</span> <span class="token function">Buzzer_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*开启时钟*/</span>    <span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_GPIOB<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//开启GPIOB的时钟</span>        <span class="token comment" spellcheck="true">/*GPIO初始化*/</span>    GPIO_InitTypeDef GPIO_InitStructure<span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_Out_PP<span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> GPIO_Pin_12<span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span>    <span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将PB12引脚初始化为推挽输出</span>        <span class="token comment" spellcheck="true">/*设置GPIO初始化后的默认电平*/</span>    <span class="token function">GPIO_SetBits</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> GPIO_Pin_12<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置PB12引脚为高电平</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**  * 函    数：蜂鸣器开启  * 参    数：无  * 返 回 值：无  */</span><span class="token keyword">void</span> <span class="token function">Buzzer_ON</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">GPIO_ResetBits</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> GPIO_Pin_12<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置PB12引脚为低电平</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**  * 函    数：蜂鸣器关闭  * 参    数：无  * 返 回 值：无  */</span><span class="token keyword">void</span> <span class="token function">Buzzer_OFF</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">GPIO_SetBits</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> GPIO_Pin_12<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置PB12引脚为高电平</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**  * 函    数：蜂鸣器状态翻转  * 参    数：无  * 返 回 值：无  */</span><span class="token keyword">void</span> <span class="token function">Buzzer_Turn</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">GPIO_ReadOutputDataBit</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> GPIO_Pin_12<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//获取输出寄存器的状态，如果当前引脚输出低电平</span>    <span class="token punctuation">{</span>        <span class="token function">GPIO_SetBits</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> GPIO_Pin_12<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//则设置PB12引脚为高电平</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span><span class="token comment" spellcheck="true">//否则，即当前引脚输出高电平</span>    <span class="token punctuation">{</span>        <span class="token function">GPIO_ResetBits</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> GPIO_Pin_12<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//则设置PB12引脚为低电平</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// LightSensor.h</span><span class="token macro property">#<span class="token directive keyword">ifndef</span> __LIGHT_SENSOR_H</span><span class="token macro property">#<span class="token directive keyword">define</span> __LIGHT_SENSOR_H</span><span class="token keyword">void</span> <span class="token function">LightSensor_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>uint8_t <span class="token function">LightSensor_Get</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// LightSensor.c</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"stm32f10x.h"</span>                  </span><span class="token comment" spellcheck="true">// Device header</span><span class="token comment" spellcheck="true">/**  * 函    数：光敏传感器初始化  * 参    数：无  * 返 回 值：无  */</span><span class="token keyword">void</span> <span class="token function">LightSensor_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*开启时钟*/</span>    <span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_GPIOB<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//开启GPIOB的时钟</span>        <span class="token comment" spellcheck="true">/*GPIO初始化*/</span>    GPIO_InitTypeDef GPIO_InitStructure<span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_IPU<span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> GPIO_Pin_13<span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span>    <span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将PB13引脚初始化为上拉输入</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**  * 函    数：获取当前光敏传感器输出的高低电平  * 参    数：无  * 返 回 值：光敏传感器输出的高低电平，范围：0/1  */</span>uint8_t <span class="token function">LightSensor_Get</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">GPIO_ReadInputDataBit</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> GPIO_Pin_13<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//返回PB13输入寄存器的状态</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> GPIO </tag>
            
            <tag> 蜂鸣器 </tag>
            
            <tag> 光敏传感器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01-STM32介绍和工程环境配置</title>
      <link href="/2024/12/17/01-stm32-jie-shao-he-gong-cheng-huan-jing-pei-zhi/"/>
      <url>/2024/12/17/01-stm32-jie-shao-he-gong-cheng-huan-jing-pei-zhi/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="STM32入门教程（江协）"><a href="#STM32入门教程（江协）" class="headerlink" title="STM32入门教程（江协）"></a>STM32入门教程（江协）</h1><h2 id="1-1-课程简介"><a href="#1-1-课程简介" class="headerlink" title="1-1 课程简介"></a>1-1 课程简介</h2><p>硬件平台：STM32最小系统板+面包板硬件平台</p><p>软件设备：Keil5 MDK(给ARM系列的单片机编程的)</p><h2 id="1-2-STM32简介"><a href="#1-2-STM32简介" class="headerlink" title="1-2 STM32简介"></a>1-2 STM32简介</h2><ol><li><p>STM32简介</p><ul><li>STM32是ST公司基于ARM Cortex-M内核开发的32位微控制器</li><li>STM32常应用在嵌入式领域，如智能车、无人机、机器人、无线通信、物联网、工业控制、娱乐电子产品等</li><li>STM32功能强大、性能优异、片上资源丰富、功耗低，是一款经典的嵌入式微控制器</li></ul><p><img src="https://www.st.com.cn/content/dam/category-pages/stm32-32-bit-arm-cortex-mcus/arm_cortex_mcu_portfolio_new.jpg"></p></li><li><p>ARM</p><ul><li>ARM既指ARM公司，也指ARM处理器内核</li><li>ARM公司是全球领先的半导体知识产权（IP）提供商，全世界超过95%的智能手机和平板电脑都采用ARM架构</li><li>ARM公司设计ARM内核，半导体厂商完善内核周边电路并生产芯片</li></ul><p><img src="https://pic.imgdb.cn/item/67612b42d0e0a243d4e52734.png"></p></li><li><p>STM32F103C8T6</p><ul><li>系列：主流系列STM32F1</li><li>内核：ARM Cortex-M3</li><li>主频：72MHz</li><li>RAM：20K(SRAM)</li><li>ROM: 64K(Flash)</li><li>供电：2.0~3.6V（标准3.3V)</li><li>封装：LQFP48</li></ul></li><li><p>片上资源/外设</p><table><thead><tr><th align="center">英文缩写</th><th align="center">名称</th><th align="center">英文缩写</th><th align="center">名称</th></tr></thead><tbody><tr><td align="center"><strong>NVIC</strong></td><td align="center"><strong>嵌套向量中断控制器</strong></td><td align="center">CAN</td><td align="center">CAN通信</td></tr><tr><td align="center"><strong>SysTick</strong></td><td align="center"><strong>系统滴答定时器</strong></td><td align="center">USB</td><td align="center">USB通信</td></tr><tr><td align="center">RCC</td><td align="center">复位和时钟控制</td><td align="center">RTC</td><td align="center">实时时钟</td></tr><tr><td align="center">GPIO</td><td align="center">通用IO口</td><td align="center">CRC</td><td align="center">CRC校验</td></tr><tr><td align="center">AFIO</td><td align="center">复用IO口</td><td align="center">PWR</td><td align="center">电源控制</td></tr><tr><td align="center">EXTI</td><td align="center">外部中断</td><td align="center">BKP</td><td align="center">备份寄存器</td></tr><tr><td align="center">TIM</td><td align="center">定时器</td><td align="center">IWDG</td><td align="center">独立看门狗</td></tr><tr><td align="center">ADC</td><td align="center">模数转换器</td><td align="center">WWDG</td><td align="center">窗口看门狗</td></tr><tr><td align="center">DMA</td><td align="center">直接内存访问</td><td align="center">DAC</td><td align="center">数模转换器</td></tr><tr><td align="center">USART</td><td align="center">同步/异步串口通信</td><td align="center">SDIO</td><td align="center">SD卡接口</td></tr><tr><td align="center">I2C</td><td align="center">I2C通信</td><td align="center">FSMC</td><td align="center">可变静态存储控制器</td></tr><tr><td align="center">SPI</td><td align="center">SPI通信</td><td align="center">USB OTG</td><td align="center">USB主机接口</td></tr></tbody></table></li><li><p>命名规则</p><p><img src="https://shequ.stmicroelectronics.cn/data/attachment/forum/201709/16/151144mewf6r62wppxpefe.jpg"></p></li><li><p>系统结构</p><p><img src="https://raw.githubusercontent.com/flyingBridzz/flyingBridzz.github.io/master/_posts/image/STM32%E7%B3%BB%E7%BB%9F%E6%9E%84%E6%9E%B6/1.png"></p></li><li><p>引脚定义</p><p><img src="https://pic.imgdb.cn/item/67619080d0e0a243d4e589df.png"></p></li><li><p>启动配置</p><p><img src="https://pic.imgdb.cn/item/676128ecd0e0a243d4e5227a.png"></p></li><li><p>最小系统电路</p><p><img src="https://pic.imgdb.cn/item/67612c0cd0e0a243d4e528d2.png"></p></li></ol><h2 id="2-1-软件安装"><a href="#2-1-软件安装" class="headerlink" title="2-1 软件安装"></a>2-1 软件安装</h2><p><a href="https://www.bilibili.com/video/BV1th411z7sn?spm_id_from=333.788.videopod.episodes&amp;vd_source=6c74875e4fc2627ae811a62db47bf683&amp;p=3" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1th411z7sn?spm_id_from=333.788.videopod.episodes&amp;vd_source=6c74875e4fc2627ae811a62db47bf683&amp;p=3</a></p><h2 id="2-2-新建工程"><a href="#2-2-新建工程" class="headerlink" title="2-2 新建工程"></a>2-2 新建工程</h2><h3 id="操作寄存器构建STM32"><a href="#操作寄存器构建STM32" class="headerlink" title="操作寄存器构建STM32"></a>操作寄存器构建STM32</h3><ul><li><p>打开Keil5，点击Project中的New uVision Project，选择项目文件夹，给工程文件命名</p></li><li><p>选择芯片型号STM32F103C8T6，之后会弹出Keil软件新建功能小助手，叉掉</p></li><li><p>添加工程的必要文件</p><ul><li>找到启动文件：<code>固件库\STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm</code>下的所有启动文件<code>ctr+a</code>、<code>ctr+c</code></li><li>回到工程文件夹下，新建文件夹<code>Start</code>，将复制的内容粘贴到里面</li><li>回到固件库的<code>STM32F10x</code>的文件夹下，有<code>stm32f10x.h文件</code>（<strong>STM32的外设寄存器描述文件，用来描述STM32有哪些寄存器和它对应的地址的</strong>）、<code>system_stm32f10x.c</code>和<code>system_stm32f10x.h</code>文件（<strong>用来配置时钟的，STM32主频72MHz，就是system文件里的函数配置的</strong>），将这三个文件复制下来，也粘贴到Start文件夹下</li><li>STM32是内核和内核外围的设备组成的，但是内核的寄存器描述和外围设备的描述文件不是在一起的，还需要添加一个内核寄存器的描述文件。找到<code>\CM3\CoreSupport\</code>下的两个cm3（Cortex-M3)(core_cm3.c和core_cm3.h)，粘贴到Start文件夹下。</li></ul></li><li><p>回到Keil软件，将刚刚复制的那些文件添加到工程里来，创建一个Start文件夹，右击添加已经存在的文件，选择All files，添加一个启动文件（后缀名md.s)，所有的.c，.h文件，按住Ctr 进行选择，Add添加</p></li><li><p>在工程选项里添加上这个文件夹的头文件路径。点击魔术棒按键，打开工程选项，在<strong>C/C++<strong>里找到</strong>Include Paths</strong>栏点击三个点的按钮，把Start的路径添加进来</p></li><li><p>打开工程文件夹创建User文件夹，该文件夹存放main函数。回到Keil软件右击Target增加组，改名为User，右击User添加新文件main.c，路径选择工程文件夹下的User。</p></li><li><p>在main.c文件里，右击添加<code>stm32f10x.h</code>，创建一个main.c，编译并建立工程。目前这是一个寄存器工程。</p><p>选择魔术棒找到Debug，使用<code>ST-Link Debugger</code>调试器，点击Setting，找到Flash Download，勾上Reset and Run(下载程序后会立马复位执行，不需要按Reset)</p><p>查看STM32F10xxx参考手册，找到RCC寄存器下的APB2外设时钟使能寄存器(<strong>RCC_APB2ENR</strong>)</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"stm32f10x.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    RCC<span class="token operator">-></span>APB2ENR <span class="token operator">=</span> <span class="token number">0x00000010</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 打开GPIOC的时钟了  </span>    GPIOC<span class="token operator">-></span>CRH <span class="token operator">=</span> <span class="token number">0x00300000</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 配置CNF13、MODE13   0011 推挽输出模式</span>    GPIOC<span class="token operator">-></span>ODR <span class="token operator">=</span> <span class="token number">0x00000000</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 低电平点亮  0x00002000  熄灭</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//最后一行要为空，否则会报警告</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="操作库函数构建STM32"><a href="#操作库函数构建STM32" class="headerlink" title="操作库函数构建STM32"></a>操作库函数构建STM32</h3><ul><li><p>在原有的工程文件夹下建立Library文件夹，打开固件库的文件夹，<code>STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\STM32F10x_StdPeriph_Driver</code>下有库函数的源文件和头文件，其中misc.c是内核的库函数，将其复制到Library文件夹下。</p></li><li><p>在Keil下建立Library组，将库函数添加进去。还需要一些文件，打开固件库中的<code>\STM32F10x_StdPeriph_Lib_V3.5.0\Project\STM32F10x_StdPeriph_Template</code>下的<code>stm32f10x_conf.h</code>(<strong>用来配置库函数头文件的包含关系的、还有用来参数检查的函数定义</strong>)、<code>stm32f10x_it.c、stm32f10x_it.h</code>(<strong>中断处理</strong>)，将其复制到工程下的User目录下，在Keil软件的User组下进行添加。</p></li><li><p>还需要一个宏定义。打开<code>stm32f10x.h</code>文件，发现最后一段有这几条语句，只有定义了<strong>USE_STDPERIPH_DRIVER</strong>字符串，才能包含<strong>stm32f10x_conf.h</strong>这个文件。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#ifdef USE_STDPERIPH_DRIVER</span>  <span class="token comment" spellcheck="true">#include "stm32f10x_conf.h"</span><span class="token comment" spellcheck="true">#endif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>打开魔术棒，找到C/C++，然后定义该字符串。在头文件路径下，还要增加User和Library目录的路径。</p></li><li><p>编译后没问题，开始编写main函数</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"stm32f10x.h"</span>     </span><span class="token comment" spellcheck="true">// Device Header</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_GPIOC<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 开启GPIOC的时钟</span>        GPIO_InitTypeDef GPIO_InitStructure<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 配置模式  端口  速度</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_Out_PP<span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> GPIO_Pin_13<span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span>    <span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOC<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">GPIO_SetBits</span><span class="token punctuation">(</span>GPIOC<span class="token punctuation">,</span> GPIO_Pin_13<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 输出高电平</span>    <span class="token function">GPIO_ResetBits</span><span class="token punctuation">(</span>GPIOC<span class="token punctuation">,</span> GPIO_Pin_13<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 输出低电平</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ol><li><p>启动类型选择</p><table><thead><tr><th align="left">缩写</th><th align="center">释义</th><th align="left">Flash容量</th><th>型号</th></tr></thead><tbody><tr><td align="left">LD_VL</td><td align="center">小容量产品超值系列</td><td align="left">16~32K</td><td>STM32F100</td></tr><tr><td align="left">MD_VL</td><td align="center">中容量产品超值系列</td><td align="left">64~128K</td><td>STM32F100</td></tr><tr><td align="left">HD_VL</td><td align="center">大容量产品超值系列</td><td align="left">256~512K</td><td>STM32F100</td></tr><tr><td align="left">LD</td><td align="center">小容量产品</td><td align="left">16~32K</td><td>STM32F101/102/103</td></tr><tr><td align="left">MD</td><td align="center">中容量产品</td><td align="left">64~128K</td><td>STM32F101/102/103</td></tr><tr><td align="left">HD</td><td align="center">大容量产品</td><td align="left">256~512K</td><td>STM32F101/102/103</td></tr><tr><td align="left">XL</td><td align="center">加大容量产品</td><td align="left">大于512K</td><td>STM32F101/102/103</td></tr><tr><td align="left">CL</td><td align="center">互联型产品</td><td align="left">-</td><td>STM32F105/107</td></tr></tbody></table></li><li><p>新建工程步骤</p><ul><li>建立工程文件夹，Keil中新建工程，选择型号</li><li>工程文件夹里建立Start、Library、User等文件夹，复制固件库里面的文件到工程文件夹</li><li>工程里对应建立Start、Library、User等同名称的分组，然后将文件夹内的文件添加到工程分组里</li><li>工程选项，C/C++，Include Paths内声明所有包含头文件的文件夹</li><li>工程选项，C/C++，Define内定义USE_STDPERIPH_DRIVER</li><li>工程选项，Debug，下拉列表选择对应调试器，Settings，Flash Download里勾选Reset and Run</li></ul></li><li><p>工程架构</p><p><img src="https://pic.imgdb.cn/item/6761738ed0e0a243d4e5829d.png"></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> 环境搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo的搭建过程</title>
      <link href="/2024/12/16/hexo-de-da-jian-guo-cheng/"/>
      <url>/2024/12/16/hexo-de-da-jian-guo-cheng/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="hexo博客的安装过程"><a href="#hexo博客的安装过程" class="headerlink" title="hexo博客的安装过程"></a>hexo博客的安装过程</h2><blockquote><p>使用ubuntu22 进行安装，然后关联github，选择主题Matery</p></blockquote><h3 id="安装Nodejs-和-Hexo-cli"><a href="#安装Nodejs-和-Hexo-cli" class="headerlink" title="安装Nodejs 和 Hexo-cli"></a>安装Nodejs 和 Hexo-cli</h3><p>1.卸载旧版本的 Node.js:</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> apt remove nodejs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.安装最新版本的Node.js(如v18 LTS)</p><pre class="line-numbers language-bash"><code class="language-bash">curl -fsSL https://deb.nodesource.com/setup_18.x <span class="token operator">|</span> <span class="token function">sudo</span> -E <span class="token function">bash</span> -<span class="token function">sudo</span> apt <span class="token function">install</span> -y nodejs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>3.验证安装版本</p><pre class="line-numbers language-bash"><code class="language-bash">node -v<span class="token function">npm</span> -v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>4.安装Hexo-cli</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">npm</span> <span class="token function">install</span> -g hexo-clihexo -v     <span class="token comment" spellcheck="true">#查看安装是否成功</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="创建和运行Hexo博客"><a href="#创建和运行Hexo博客" class="headerlink" title="创建和运行Hexo博客"></a>创建和运行Hexo博客</h3><p>1.创建博客项目</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">mkdir</span> my-blog   <span class="token comment" spellcheck="true"># 创建博客目录</span><span class="token function">cd</span> my-blog      <span class="token comment" spellcheck="true"># 进入目录</span>hexo init       <span class="token comment" spellcheck="true"># 初始化 Hexo 博客</span><span class="token function">npm</span> <span class="token function">install</span>     <span class="token comment" spellcheck="true"># 安装依赖</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>2.启动本地服务器</p><pre class="line-numbers language-bash"><code class="language-bash">hexo server    <span class="token comment" spellcheck="true"># 本地运行</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>打开浏览器，访问：<code>http://localhost:4000</code></p></li><li><p>能看到Hexo默认的博客页面</p></li></ul><p>3.创建新文章</p><pre class="line-numbers language-bash"><code class="language-bash">hexo new <span class="token string">"我的第一篇文章"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>打开<code>source/_posts</code> 文件夹，找到新建的 .md 文件。</li><li>使用文本编辑器编辑文件，添加内容：<pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token punctuation">-</span> <span class="token punctuation">-</span><span class="token punctuation">-</span>    <span class="token key atrule">title</span><span class="token punctuation">:</span> 我的第一篇文章<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2024-12-16 12:00:00</span><span class="token key atrule">tags</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>Hexo<span class="token punctuation">,</span> 博客<span class="token punctuation">]</span><span class="token punctuation">-</span> <span class="token punctuation">-</span><span class="token punctuation">-</span>这是我的第一篇 Hexo 博客文章！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>4.生成静态文件</p><pre class="line-numbers language-bash"><code class="language-bash">hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>5.部署到 <strong>GitHub Pages</strong></p><ol><li><p>安装部署插件</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-git --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>配置<code>_config.yml</code>文件</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">deploy</span><span class="token punctuation">:</span><span class="token key atrule">type</span><span class="token punctuation">:</span> git<span class="token key atrule">repo</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//github.com/你的用户名/你的仓库.git  <span class="token comment" spellcheck="true"># git@github.com:404djl/404djl.github.io.git </span><span class="token comment" spellcheck="true"># 仓库名一定是 用户名.github.io</span><span class="token key atrule">branch</span><span class="token punctuation">:</span> main     <span class="token comment" spellcheck="true"># 仓库的分支名</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>向github配置ssh密钥</p><p> 使用<code>ssh-keygen -t rsa -b 4096 -C "your_email@example.com"</code>命令生成SSH密钥对</p><p> 默认情况下，密钥会存储在~/.ssh/目录下，私钥文件名为id_rsa，公钥文件名为id_rsa.pub</p><p> 复制id_rsa.pub文件的内容，打开github，设置里的SSH，进行添加<br> <img src="https://pic.imgdb.cn/item/67603a72d0e0a243d4e4f8b7.png"></p></li><li><p>部署博客：</p><pre class="line-numbers language-bash"><code class="language-bash">hexo clean          <span class="token comment" spellcheck="true"># 清理缓存与静态文件</span>hexo generate       <span class="token comment" spellcheck="true"># 也可以 hexo g 生成静态文件</span>hexo deploy         <span class="token comment" spellcheck="true"># 也可以 hexo d 部署到远程仓库</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><p><span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> blog </tag>
            
            <tag> Matery </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
